{
  "id": "sML2JBPsdAyCMAUuDAb4rMUzpB9GRgBrSJo6frY3aqUzYMyY1KqfA5MTDk9Bkxae",
  "title": "Blog - Bitfield Consulting",
  "displayTitle": "Dev - Bitfield",
  "url": "https://bitfieldconsulting.com/posts?format=rss",
  "feedLink": "https://bitfieldconsulting.com/posts/",
  "items": [
    {
      "title": "Rust vs Go in 2024 and 2025",
      "url": "https://bitfieldconsulting.com/posts/rust-vs-go",
      "date": 1730279040,
      "author": "John Arundel",
      "unread": true,
      "desc": "",
      "content": "<figure class=\"\n              sqs-block-image-figure\n              intrinsic\n            \"\n        >\n          \n        \n        \n\n        \n          \n            \n          \n            \n                \n                \n                \n                \n                \n                \n                \n                <img data-stretch=\"false\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png\" data-image-dimensions=\"744x350\" data-image-focal-point=\"0.5,0.5\" alt=\"\" data-load=\"false\" elementtiming=\"system-image-block\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1000w\" width=\"744\" height=\"350\" sizes=\"(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw\" onload=\"this.classList.add(&quot;loaded&quot;)\" srcset=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=2500w 2500w\" loading=\"lazy\" decoding=\"async\" data-loader=\"sqs\">\n\n            \n          \n        \n          \n        \n\n        \n      \n        </figure>\n      \n\n    \n  \n\n\n  \n\n\n\n\n\n  <p class=\"\"><strong>Can I say something without everyone getting mad?</strong></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n<p>Which is better, Rust or Go? Which language should you choose for\nyour next project, and why? How do the two compare in areas like\nperformance, simplicity, safety, features, scale, and concurrency? What\ndo they have in common, and where do they fundamentally differ? Let’s\nfind out, in this friendly and even-handed comparison of Rust and\nGolang.</p>\n<p>As it happens, I teach (and write about) both <a href=\"https://bitfieldconsulting.com/courses/learn-go\">Go</a> and <a href=\"https://bitfieldconsulting.com/courses/learn-rust\">Rust</a> professionally, and I’m also a keen\nuser of both languages, which I suspect makes me something of an\noutlier: I’ve got a foot in both camps! Since there can be a fair amount\nof perfectly understandable tribal feeling about one’s favourite\nprogramming language, maybe it’ll be helpful to get a new perspective,\nfrom someone who loves both Rust and Go. Here’s why.</p>\n<h2 id=\"rust-and-go-are-both-awesome\">Rust and Go are both awesome</h2>\n<p>First, it’s really important to say that <em>both Go and Rust are\nabsolutely excellent programming languages</em>. They’re modern,\npowerful, widely-adopted, and offer excellent performance.</p>\n<p>In my book <a href=\"https://bitfieldconsulting.com/books/rust-tools\">The Secrets of Rust:\nTools</a>, I describe Rust this way:</p>\n<blockquote>\n<p><em>Graydon Hoare, the originator of Rust, described it as <a href=\"http://venge.net/graydon/talks/intro-talk-2.pdf\">“technology from\nthe past, come to save the future from itself”</a>. He wanted to build,\nnot a new, exciting, and experimental programming language, but a solid,\nboring, reliable language, based on proven ideas that work. A language,\nin other words, that would incorporate the many hard lessons we’ve\nlearned about good software development over the past hundred or two\nyears.</em><br />\n</p>\n</blockquote>\n<p>And here’s how I describe Go in my book <a href=\"https://bitfieldconsulting.com/books/love\">For the\nLove of Go</a>:</p>\n<blockquote>\n<p><em>Go is humble and pragmatic: it doesn’t have all the high-tech\nfeatures and theoretical advantages of some other languages. Indeed, it\ndeliberately leaves out many features that are big selling points of\nother languages. Its designers were less interested in creating an\nimpressive programming language, or in topping popularity polls, than in\ngiving people a small and simple tool for getting useful work done in\nthe most practical and direct way possible.</em><br />\n</p>\n</blockquote>\n<p>So perhaps Rust and Go have more in common than you might think! But\nthey are, of course, very different languages in practice, and neither\nof them is the perfect tool to solve every problem.</p>\n<p>In this article, I’ll try to give a brief overview of where I think\nGo is the ideal choice, and where I think Rust is a better\nalternative.</p>\n<h2 id=\"similarities\">Similarities</h2>\n<p>What are some of the common goals of both languages?</p>\n<h3 id=\"memory-safety\">Memory safety</h3>\n<p>Historically, one of the biggest causes of software bugs and security\nvulnerabilities has been accessing memory unsafely or incorrectly.</p>\n<p>Rust and Go deal with this problem in different ways, but both aim to\nbe smarter and safer than other languages about managing memory.</p>\n<blockquote>\n<p><a href=\"https://x.com/bitfield/status/1789585655892160808\">The\ngenius of Go is that it has a garbage collector. The genius of Rust is\nthat it doesn’t need one.</a></p>\n</blockquote>\n<h3 id=\"fast-compact-executables\">Fast, compact executables</h3>\n<p>They’re both compiled languages, which means your programs are\ntranslated directly to executable machine code, so that you can deploy\nyour program as a single binary file. This also makes both Rust and Go\nprograms extremely fast in comparison to interpreted languages such as\nPython or Ruby.</p>\n<h3 id=\"general-purpose-languages\">General-purpose languages</h3>\n<p>Rust and Go are also both powerful, scalable general-purpose\nprogramming languages, which you can use to develop all kinds of modern\nsoftware. Both have excellent standard libraries and a thriving\nthird-party ecosystem, as well as great commercial support and a large\nuser base.</p>\n<h3 id=\"pragmatic-programming-style\">Pragmatic programming style</h3>\n<p>While both Go and Rust have features associated with functional and\nobject-oriented programming (OOP), they’re pragmatic languages aimed at\nsolving problems in whatever way is most appropriate.</p>\n<h3 id=\"development-at-scale\">Development at scale</h3>\n<p>Both Rust and Go have some useful features which make them suitable\nfor programming in the large, whether that means large teams, or large\ncodebases, or both.</p>\n<p>For example, both Rust and Go use a standard code formatting tool\n(<code>gofmt</code> for Go, <code>rustfmt</code> for Rust), putting an\nend to useless arguments over where to put your brackets.</p>\n<p>Both also have excellent, built-in, high-performance standard build\nand dependency management tools; no more wrestling with complex\nthird-party build systems and having to learn a new one every couple of\nyears.</p>\n<h2 id=\"differences\">Differences</h2>\n<p>While Rust and Go have a lot in common, there are also a few areas\nwhere a reasonable person might prefer one language over the other, to\nmeet the specific needs of their project.</p>\n<h2 id=\"performance\">Performance</h2>\n<p>Both Go and Rust are very fast. However, while Go’s design favours\nfast compilation, Rust is optimised for fast execution.</p>\n<p>Rust’s run-time performance is also more consistent, because it\ndoesn’t use garbage collection. On the other hand, Go’s garbage\ncollector takes some of the burden off the programmer, making it easier\nto focus on solving the main problem, rather than the fine detail of\nmemory management.</p>\n<p>Rust is a better choice for areas where speed of execution beats all\nother considerations, such as game programming, operating system\nkernels, web browser components, and real-time control systems.</p>\n<h2 id=\"simplicity\">Simplicity</h2>\n<blockquote>\n<p>Go is incredibly easy to learn. I know this is an often-touted\nbenefit, but I was really surprised at how quickly I was able to be\nproductive. Thanks to the language, docs, and tools, I was writing\ninteresting, committable code after literally two days.<br />\n—<a href=\"https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410\">Early\nImpressions of Go From a Rust Programmer</a></p>\n</blockquote>\n<p>Go is a small language, by design: it has very little syntax, few\nkeywords, and as few language constructs as it can get away with. You\ncan learn the basics of Go and be productive in the language very\nquickly.</p>\n<p>That gives Go the advantage in projects with a short timescale, or\nfor teams that need to onboard lots of new programmers quickly,\nespecially if they’re relatively inexperienced.</p>\n<blockquote>\n<p>With Go, you get things done—fast. Go is one of the most productive\nlanguages I’ve ever worked with. The mantra is: solve real problems\ntoday.<br />\n—<a href=\"https://endler.dev/2017/go-vs-rust/\">Matthias Endler</a></p>\n</blockquote>\n<p>On the other hand, the very simplicity of Go means that you need to\nwrite more code to solve certain problems: the language does less of the\nheavy lifting for you. It also doesn’t suit some programmers who like a\nvery rich, expressive language that gives them many different ways to\nsolve a problem.</p>\n<h2 id=\"features\">Features</h2>\n<p>At the other end of the scale, Rust has just about every feature you\ncould imagine in a programming language, and some you probably can’t.\nThat makes it a powerful and expressive language, with lots of different\nways to do the same thing.</p>\n<blockquote>\n<p>Rust supports more complexity than several other programming\nlanguages, therefore, you can achieve more with it.<br />\n—<a href=\"https://devathon.com/blog/rust-vs-go-which-programming-language-to-choose/\">Devathon</a></p>\n</blockquote>\n<p>If you’re transitioning to Rust from some other language, you can\nprobably find Rust equivalents for most of the features you’re used to.\nThat gives Rust the advantage when large projects need to be migrated\nfrom a traditional language such as C++ or Java.</p>\n<blockquote>\n<p>Rust competes for mindshare with C++ and D for programmers who are\nprepared to accept more complex syntax and semantics (and presumably\nhigher readability costs) in return for the maximum possible\nperformance.<br />\n—<a href=\"https://dave.cheney.net/2015/07/02/why-go-and-rust-are-not-competitors\">Dave\nCheney</a></p>\n</blockquote>\n<p>And, while it’s a bigger language than Go, Rust is still relatively\neasy to learn:</p>\n<blockquote>\n<p>Rust is a cleaner, more easily understood and friendlier language\nthan most—and certainly much easier to understand than modern C++.<br />\n–<a href=\"https://tweedegolf.nl/en/blog/140/rust-needs-an-official-specification\">Marc\nSchoolderman</a></p>\n</blockquote>\n<p>On the other hand, the complexity of Rust, and the new way of\nthinking about problems that it requires, makes experienced Rust\ndevelopers expensive, and it can take longer to ramp up junior\ndevelopers to a level where they can be productive. Rust might not be\nthe best choice for projects that need very rapid development or\nprototyping, or where cost is a bigger factor than safety and\nreliability.</p>\n<p>To summarise:</p>\n<blockquote>\n<p><a href=\"https://x.com/bitfield/status/1797919806861254680\">Go is too\nsimple to write complicated programs, while Rust is too complicated to\nwrite simple programs. It all depends which problem you’d rather\nhave.</a></p>\n</blockquote>\n<h2 id=\"concurrency\">Concurrency</h2>\n<p>Most languages have some form of support for concurrent programming\n(doing multiple things at once), but Go’s support is second to none.\nInstead of using operating system threads, which are relatively clumsy\nand slow, Go provides a lightweight solution: <em>goroutines</em>. You\ncan run millions of concurrent goroutines in a single program without\ncreating serious performance problems, which makes Go the perfect choice\nfor high-scale concurrent applications such as webservers and\nmicroservices.</p>\n<p>Go also features fast, safe, efficient ways for goroutines to\ncommunicate and share data, using <em>channels</em>. Go’s concurrency\nsupport feels well-designed, and a pleasure to use. Because it was built\nin to the language from the start, instead of being an afterthought,\nconcurrent programming in Go is simple and well-integrated.</p>\n<blockquote>\n<p>Having lightweight syntax for spawning Go routines and using channels\nis really nice. It really shows the power of syntax that such small\ndetails make concurrent programming feel so much nicer than in other\nlanguages.<br />\n—<a href=\"https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410\">Early\nImpressions of Go From a Rust Programmer</a></p>\n</blockquote>\n<p>This makes Go the perfect choice for high-scale concurrent\napplications such as webservers and microservices.</p>\n<blockquote>\n<p>Go makes it very easy to build a nicely factored application that\ntakes full advantage of concurrency while being deployed as a set of\nmicroservices. Rust can do those things, too, but it’s arguably a bit\ntougher. In some respects, Rust’s obsession with preventing\nmemory-related security vulnerabilities means that programmers have to\ngo out of their way to perform tasks that would be simpler in other\nlanguages, including Go.<br />\n—<a href=\"https://sdtimes.com/softwaredev/the-developers-dilemma-choosing-between-go-and-rust/\">Sonya\nKoptyev</a></p>\n</blockquote>\n<h2 id=\"safety\">Safety</h2>\n<p>Rust is carefully designed to ensure that programmers can’t do\nsomething unsafe that they didn’t mean to do, such as overwriting a\nshared variable. The compiler requires you to be explicit about the way\nyou share data between different parts of the program, and can detect\nmany common mistakes and bugs.</p>\n<blockquote>\n<p>Rust’s very strict and pedantic compiler checks each and every\nvariable you use and every memory address you reference. It avoids\npossible data race conditions and informs you about undefined behavior.\nConcurrency and memory safety issues are fundamentally impossible to get\nin the safe subset of Rust.<br />\n—<a href=\"https://bitbucket.org/blog/why-rust\">Why Rust?</a></p>\n</blockquote>\n<p>As a result, so-called “fighting with the borrow checker” is a common\ncomplaint among new Rust programmers. Implementing your program in safe\nRust code often means fundamentally re-thinking its design, which can be\nfrustrating, but the benefits can be worth it when reliability is your\ntop priority.</p>\n<p>Rust’s ownership model may force you to fundamentally re-architect\nyour program to avoid running into these issues. And that’s a good\nthing, if correctness and reliability are your top priority. What’s the\npoint of a language that doesn’t change the way you program, after all?\nBut there <em>are</em> other legitimate priorities.</p>\n<blockquote>\n<p>If you choose Rust, usually you need the guarantees that the language\nprovides: safety against null pointers and race conditions, predictable\nruntime behaviour, and total control over the hardware. If you don’t\nrequire any of these features, Rust might be a poor choice for your next\nproject. That’s because these guarantees come with a cost: ramp-up time.\nYou’ll need to unlearn bad habits and learn new concepts. Chances are,\nyou will fight with the borrow checker a lot when you start out.<br />\n—<a href=\"https://endler.dev/2017/go-vs-rust/\">Matthias Endler</a></p>\n</blockquote>\n<h2 id=\"scale\">Scale</h2>\n<p>Go was designed to make it easy to scale both your projects and your\ndevelopment teams. Its minimalist design leads to a certain uniformity,\nand the existence of a well-defined standard style means that any Go\nprogrammer can read and understand a new codebase relatively\nquickly.</p>\n<p>When it comes to software development in the large, clear is better\nthan clever. Go is a good choice for big organisations, especially with\nmany distributed teams. Its fast build times also favour rapid testing\nand deployment.</p>\n<h2 id=\"trade-offs\">Trade-offs</h2>\n<p>Rust and Go’s design teams have made some starkly different choices,\nso let’s look at some areas where those trade-offs make the two\nlanguages very distinct from one another.</p>\n<h3 id=\"garbage-collection\">Garbage collection</h3>\n<p>Languages (like Go) that feature garbage collection, and automatic\nmemory management in general, make it quick and easy to develop\nreliable, efficient programs, and for some people that’s the most\nimportant thing.</p>\n<p>But garbage collection, with its performance overhead and\nstop-the-world pauses, can make programs behave unpredictably at\nrun-time, and some people find this inconsistency unacceptable.</p>\n<p>Languages (such as Rust) where the programmer must take explicit\nresponsibility for allocating and freeing every byte of memory, are\nbetter for real-time or ultra-high-performance applications.</p>\n<blockquote>\n<p>Go is a very different language to Rust. Although both can vaguely be\ndescribed as systems languages or replacements for C, they have\ndifferent goals and applications, styles of language design, and\npriorities. Garbage collection is a really huge differentiator. Having\nGC in Go makes the language much simpler and smaller, and easy to reason\nabout. Not having GC in Rust makes it really fast (especially if you\nneed guaranteed latency, not just high throughput) and enables features\nand programming patterns that are not possible in Go (or at least not\nwithout sacrificing performance).<br />\n—<a href=\"https://medium.com/better-programming/early-impressions-of-go-from-a-rust-programmer-f4fd1074c410\">PingCAP</a></p>\n</blockquote>\n<h3 id=\"error-handling\">Error handling</h3>\n<p>In some languages, when a function encounters an error (for example,\nsomething like “file not found”), it can be handled explicitly, or it\ncan be automatically propagated back to the function’s caller, and the\ncaller’s caller, and so on, until it either finds someone willing to\nhandle the problem, or the program crashes with an ugly error\nmessage.</p>\n<p>Errors that trigger an automatic return from the function if not\nhandled are called <em>exceptions</em>, and, while convenient for\nprogrammers, can lead to some confusing behaviour—especially if the\nexceptions are used deliberately as a control flow mechanism.</p>\n<p>In both Rust and Go, while exceptions are available, their use is\nstrongly discouraged. Instead, both languages treat errors as\n<em>values</em>, like any other piece of data, rather than as a\ncontrol-flow mechanism built in to the language.</p>\n<p>And because errors can happen with almost anything you do in a\nprogram, that means a lot of Go and Rust code is about checking error\nvalues and deciding what to do about them. However, there’s a\nsignificant difference in the way the two languages handle this\nproblem.</p>\n<p>In Go, error checking is clear and explicit, and usually looks\nsomething like this:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>answer<span class=\"op\">,</span> err <span class=\"op\">:=</span> getAnswer<span class=\"op\">()</span></span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"cf\">if</span> err <span class=\"op\">!=</span> <span class=\"ot\">nil</span> <span class=\"op\">{</span></span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> err</span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// do something with `answer`</span></span></code></pre>\n<p>Many people used to languages with exceptions, where errors can\nsimply be ignored (or “kicked upstairs” for someone else to handle),\nfind the proliferation of <code>if err != nil</code> blocks irritating,\nor excessively verbose. However, despite many alternative proposals,\nnone have found widespread favour, and this idiom does at least have the\nbenefit of making the control flow clear and unambiguous.</p>\n<p><a href=\"https://bitfieldconsulting.com/posts/rust-errors-option-result\">Rust’s error handling</a>\nis even more powerful, relying on built-in <code>Option</code> and\n<code>Result</code> types which indicate that a return value may or may\nnot be present, or may instead be some error.</p>\n<p>For example, here’s how we might write the previous example in Rust,\nif <code>get_answer</code> returns <code>Option</code>, indicating that\nthere may or may not be an answer:</p>\n<pre class=\"sourceCode rust\"><code class=\"sourceCode rust\"><span id=\"cb2-1\"><a href=\"#cb2-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"cf\">if</span> <span class=\"kw\">let</span> <span class=\"cn\">Some</span>(answer) <span class=\"op\">=</span> get_answer() <span class=\"op\">{</span></span>\n<span id=\"cb2-2\"><a href=\"#cb2-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"co\">// do something with `answer`</span></span>\n<span id=\"cb2-3\"><a href=\"#cb2-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>Alternatively, if <code>get_answer</code> returns\n<code>Result</code>, meaning that there’s either an answer <em>or</em>\nan error, the code might look like this:</p>\n<pre class=\"sourceCode rust\"><code class=\"sourceCode rust\"><span id=\"cb3-1\"><a href=\"#cb3-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"cf\">match</span> get_answer() <span class=\"op\">{</span></span>\n<span id=\"cb3-2\"><a href=\"#cb3-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cn\">Ok</span>(answer) <span class=\"op\">=&gt;</span> <span class=\"co\">// do something with `answer`</span></span>\n<span id=\"cb3-3\"><a href=\"#cb3-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cn\">Err</span>(e) <span class=\"op\">=&gt;</span> <span class=\"co\">// handle the error `e` somehow</span></span>\n<span id=\"cb3-4\"><a href=\"#cb3-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>However, Rust also provides a neat syntactic shorthand: the\n<code>?</code> operator causes a function to return automatically if the\n<code>Option</code> value is not present, or the <code>Result</code>\nvalue contains an error. Since errors happen a lot, this gives Rust\nprogrammers a more compact way to write the necessary handling code than\nis available in Go:</p>\n<pre class=\"sourceCode rust\"><code class=\"sourceCode rust\"><span id=\"cb4-1\"><a href=\"#cb4-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">let</span> answer <span class=\"op\">=</span> get_answer()<span class=\"op\">?;</span></span></code></pre>\n<h3 id=\"abstraction\">Abstraction</h3>\n<p>The history of computer programming has been a story of increasingly\nsophisticated abstractions that let the programmer solve problems\nwithout worrying too much about how the underlying machine actually\nworks.</p>\n<p>That makes programs easier to write and perhaps more portable. But\nfor many programs, access to the hardware, and precise control of how\nthe program is executed, are more important.</p>\n<p>Rust aims to let programmers get “closer to the metal”, with more\ncontrol, but Go abstracts away the architectural details to let\nprogrammers get closer to the problem.</p>\n<blockquote>\n<p><a href=\"https://x.com/bitfield/status/1793913137210790137\">The key\ndifference between Rust and Go: you think you can understand Go code,\nbut you’re wrong. On the other hand, you think you CAN’T understand Rust\ncode, and you’re right.</a></p>\n</blockquote>\n<h3 id=\"speed\">Speed</h3>\n<p>Rust makes a number of design trade-offs to achieve the best possible\nexecution speed. By contrast, Go is more concerned with simplicity, and\nit’s willing to sacrifice some (run-time) performance for it.</p>\n<p>Whether you favour Rust or Go on this point depends on whether you\nspend more time waiting for your program to build, or waiting for it to\nrun.</p>\n<h3 id=\"correctness\">Correctness</h3>\n<p>Go and Rust both aim to help you write correct programs, but in\ndifferent ways: Go provides a superb built-in unit testing framework,\nfor example, and a rich standard library, while Rust is focused on\neliminating run-time bugs using its borrow checker.</p>\n<p>It’s probably fair to say that it’s easier to write a given program\nin Go, but the result may be more likely to contain bugs than the Rust\nversion. Rust imposes discipline on the programmer, but Go lets the\nprogrammer choose how disciplined they want to be about a particular\nproject.</p>\n<h2 id=\"what-now\">What now?</h2>\n<p>I hope this article has convinced you that <em>both</em> Rust and Go\ndeserve your serious consideration. You should reject the false dilemma\nthat you can only learn one or the other. In fact, the more languages\nyou know, the more valuable you are as a software developer.</p>\n<p>If you’re new to the tech industry, getting some skills in one or\nboth of these two languages should be your priority. If you’re an\nestablished developer who doesn’t yet have Go or Rust on your resume, I\nthink you’d be well advised to invest some time in acquiring them.\nLegacy languages such as C++, Python, Java, and friends will still be\naround for years to come, no doubt—that’s what “legacy” means—but they\nwouldn’t be the first things I’d pick up. New development in many large\ncompanies is now restricted to memory-safe languages only, which\neffectively means either Go or Rust, and probably the latter.</p>\n<p>Every new language you learn gives you new ways of thinking about\nproblems, and that can only be a good thing. The most important factor\nin the quality and success of any software project is not the choice of\nlanguage, but the skill of the programmer. You will <em>be</em> most\nskilful when using the language that suits you best, and that you enjoy\nprogramming in the most. So, if the question is “Should I learn Rust or\nGo?”, the only right answer is “Yes.”</p>\n&nbsp;\n\n\n\n\n  \n\n  \n\n    \n        \n        \n          <a href=\"https://bitfieldconsulting.com/books/love\">\n            \n\n            <img class=\"sqs-product-block-main-image\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/b4ae444f-3a81-415d-86a2-1ce99bf9df0f/cover.png\" data-image-dimensions=\"1000x1500\" data-image-focal-point=\"0.5,0.5\" alt=\"For the Love of Go (Go 1.23 edition)\" data-load=\"false\" elementtiming=\"system-product\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/b4ae444f-3a81-415d-86a2-1ce99bf9df0f/cover.png?format=1000w\" />\n\n            \n              \n            \n          </a>\n\n          \n        \n        \n    \n\n    \n\n      \n\n      \n        \n\n\n\n$44.95\n\n      \n\n      \n\n      \n        \n\n        \n\n        \n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    Add To Cart\n  \n\n      \n\n    \n\n  \n\n\n\n\n\n\n\n\n\n  \n\n  \n\n    \n        \n        \n          <a href=\"https://bitfieldconsulting.com/books/rust-tools\">\n            \n\n            <img class=\"sqs-product-block-main-image\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/82e59084-51d1-4e8d-a6ab-abc411f660cf/cover+%28no+version%29.png\" data-image-dimensions=\"1000x1500\" data-image-focal-point=\"0.5,0.5\" alt=\"The Secrets of Rust: Tools (early access edition)\" data-load=\"false\" elementtiming=\"system-product\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/82e59084-51d1-4e8d-a6ab-abc411f660cf/cover+%28no+version%29.png?format=1000w\" />\n\n            \n              \n            \n          </a>\n\n          \n        \n        \n    \n\n    \n\n      \n\n      \n        \n\n\n\n$34.95\n\n      \n\n      \n\n      \n        \n\n        \n\n        \n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    Add To Cart\n  \n\n      \n\n    \n\n  \n\n\n\n\n&nbsp;<h2 id=\"more-resources\">More resources</h2>\n<p>Check out my selections of <a href=\"https://bitfieldconsulting.com/posts/best-rust-books\">the best\nRust books</a> and <a href=\"https://bitfieldconsulting.com/posts/best-go-books\">the best Go books</a>,\nand you’ll find plenty of fantastic learning materials. You might also\nenjoy these articles:</p>\n<ul>\n<li><a href=\"https://bitfieldconsulting.com/posts/rust-errors-option-result\">Rust error handling is\nperfect actually</a></li>\n<li><a href=\"https://bitfieldconsulting.com/posts/rust-and-go\">Rust and Go versus everything\nelse</a></li>\n</ul>\n<p>And here’s a recent episode of the excellent\n<code>go podcast()</code> where I discuss the complementary nature of\nRust and Go, and why all good programmers should be familiar with both\nlanguages:</p>\n<ul>\n<li><a href=\"https://gopodcast.dev/episodes/046-lets-talk-about-rust-with-john-arundel\">Let’s\ntalk about Rust with John Arundel</a></li>\n</ul>\n<p>If you’d like to take your journey further, you might like to\nconsider studying either <a href=\"https://bitfieldconsulting.com/courses/learn-rust\">Rust</a> or <a href=\"https://bitfieldconsulting.com/courses/learn-go\">Go</a> with me, in personal, one-to-one\ncoaching and mentoring sessions. <a href=\"https://bitfieldconsulting.com/contact\">Contact me</a> if\nyou have any questions—I’ll be happy to chat with you.</p>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Generic types in Go",
      "url": "https://bitfieldconsulting.com/posts/generic-types",
      "date": 1730363280,
      "author": "John Arundel",
      "unread": true,
      "desc": "",
      "content": "<figure class=\"\n              sqs-block-image-figure\n              intrinsic\n            \"\n        >\n          \n        \n        \n\n        \n          \n            \n          \n            \n                \n                \n                \n                \n                \n                \n                \n                <img data-stretch=\"false\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png\" data-image-dimensions=\"400x400\" data-image-focal-point=\"0.5,0.5\" alt=\"\" data-load=\"false\" elementtiming=\"system-image-block\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=1000w\" width=\"400\" height=\"400\" sizes=\"(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw\" onload=\"this.classList.add(&quot;loaded&quot;)\" srcset=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=2500w 2500w\" loading=\"lazy\" decoding=\"async\" data-loader=\"sqs\">\n\n            \n          \n        \n          \n        \n\n        \n      \n        </figure>\n      \n\n    \n  \n\n\n  \n\n\n\n\n\n  <p class=\"\"><em>From </em><a href=\"https://bitfieldconsulting.com/books/generics\" target=\"_blank\"><em>Know Go</em></a></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n<blockquote>\n<p><em>Typing is no substitute for thinking.</em><br />\n—<a href=\"https://alandix.com/wp-content/uploads/2021/07/BASIC_Oct64.pdf\">“A\nManual for BASIC”</a> </p>\n</blockquote>\n<p>This is the third in a four-part series of tutorials on generics in\nGo, extracted from my book <a href=\"https://bitfieldconsulting.com/books/generics\">Know Go</a>.</p>\n<ol type=\"1\">\n<li><a href=\"https://bitfieldconsulting.com/posts/generics\">Generics</a></li>\n<li><a href=\"https://bitfieldconsulting.com/posts/type-parameters\">Type parameters</a></li>\n<li><strong>Generic types</strong></li>\n<li><a href=\"https://bitfieldconsulting.com/posts/constraints\">Constraints</a></li>\n</ol>\n<hr />\n<p>Generic functions are great, as we saw in the <a href=\"https://bitfieldconsulting.com/posts/type-parameters\">previous tutorial</a>, but we can do more.\nWe can also write generic <em>types</em>. What does that mean?</p>\n<h2 id=\"generic-types\">Generic types</h2>\n<p>We often deal with <em>collections</em> of values in Go. For example,\nconsider this slice type:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> SliceOfInt <span class=\"op\">[]</span><span class=\"dt\">int</span></span></code></pre>\n<p>You already know that, just as an <code>int</code> variable can only\nhold <code>int</code> values, a <code>[]int</code> slice can only hold\n<code>int</code> elements. We wouldn’t want to have to also define\n<code>SliceOfFloat</code>, <code>SliceOfString</code>, and so on.</p>\n<h3 id=\"defining-a-generic-slice-type\">Defining a generic slice\ntype</h3>\n<p>Could we write a <em>generic</em> type definition that takes a type\nparameter, just like a generic function? For example, could we make a\nslice of any type?</p>\n<p>Yes, we could:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb2-1\"><a href=\"#cb2-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Bunch<span class=\"op\">[</span>E <span class=\"dt\">any</span><span class=\"op\">]</span> <span class=\"op\">[]</span>E</span></code></pre>\n<p>Just as we could define a function such as <code>Len</code> that\ntakes a slice of an arbitrary element type, we’ve now given a name to a\nnew <em>type</em>: a slice of E, for some type E.</p>\n<p>And just as with generic functions, a generic type is always\n<em>instantiated</em> on some specific type when it’s used in a program.\nThat is to say, a <code>Bunch[int]</code> will be a slice of\n<code>int</code>, a <code>Bunch[string]</code> will be a slice of\nstrings, and so on.</p>\n<p>Each of these is a distinct concrete type, as you’d expect, and we\ncan write a <code>Bunch</code> literal by giving the type we want in\nsquare brackets:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb3-1\"><a href=\"#cb3-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>b <span class=\"op\">:=</span> Bunch<span class=\"op\">[</span><span class=\"dt\">int</span><span class=\"op\">]{</span><span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">}</span></span></code></pre>\n<h3 id=\"the-elements-all-have-the-same-type\">The elements all have the\nsame type</h3>\n<p>It’s very important to understand that, even though a\n<code>Bunch</code> is defined as a slice of E for any type E, any\n<em>particular</em> <code>Bunch</code> can’t contain values of\n<em>different</em> types. All the elements of a <code>Bunch[T]</code>\nmust be of type T, whatever it is.</p>\n<p>For example, we can’t create a <code>Bunch</code> of one type, and\nthen try to append a value of a different type:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb4-1\"><a href=\"#cb4-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>b <span class=\"op\">:=</span> Bunch<span class=\"op\">[</span><span class=\"dt\">int</span><span class=\"op\">]{</span><span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">}</span></span>\n<span id=\"cb4-2\"><a href=\"#cb4-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>b <span class=\"op\">=</span> <span class=\"bu\">append</span><span class=\"op\">(</span>b<span class=\"op\">,</span> <span class=\"st\">&quot;hello&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb4-3\"><a href=\"#cb4-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// cannot use &quot;hello&quot; (untyped string constant) as int value in </span></span>\n<span id=\"cb4-4\"><a href=\"#cb4-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// argument to append</span></span></code></pre>\n<p>We can have a <code>Bunch[int]</code> <em>or</em> a\n<code>Bunch[string]</code> <em>or</em> a <code>Bunch</code> of elements\nof any other specific type. What we can’t have is a <code>Bunch</code>\nof <em>mixed-type</em> elements.</p>\n<p>It’s easy to hear a term like “generic slice” and jump to the\nconclusion that it means “slice containing values of different types”.\nBut that’s actually not the case.</p>\n<h3 id=\"generic-types-need-to-be-instantiated\">Generic types need to be\ninstantiated</h3>\n<p>There are, in a sense, <em>no generic types in Go</em>. I know that\nsounds crazy, but stick with me.</p>\n<p>That is, you can <em>define</em> generic types like\n<code>Bunch[E]</code>, but to actually use them in your program, you\nneed to <em>instantiate</em> them on some specific type, like\n<code>int</code>.</p>\n<p>At that point, what you have is an ordinary Go slice of\n<code>int</code>, and it stands to reason that such a slice can only\ncontain <code>int</code> elements.</p>\n<p>So just because we used a type parameter, it doesn’t mean we can\ncreate a single slice that contains elements of different types. What we\ncan create are different <em>slice types</em>, such as\n<code>[]int</code>, or <code>[]string</code>, without having to specify\ntheir element type in advance.</p>\n<p>One way to express this is to say that, while we can define generic\ntypes at compile time, there are no generic types <em>at run\ntime</em>.</p>\n<p>There’s one partial exception to this, which you’re already familiar\nwith: interface types. We could always create a slice of\n<code>any</code> in Go, and populate it with elements of different\ndynamic types. But, for the reasons we’ve discussed, this isn’t the same\nthing as a truly generic type.</p>\n<h3 id=\"exercise-group-therapy\">Exercise: Group therapy</h3>\n<p>Over to you again now, to try your hand at the <a href=\"https://github.com/bitfield/know-go/tree/main/exercises/group\"><code>group</code></a>\nexercise. This time, you’ll need to define a generic slice type\n<code>Group[E]</code> to pass the following test:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb5-1\"><a href=\"#cb5-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestGroupContainsWhatIsAppendedToIt<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb5-2\"><a href=\"#cb5-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb5-3\"><a href=\"#cb5-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    got <span class=\"op\">:=</span> group<span class=\"op\">.</span>Group<span class=\"op\">[</span><span class=\"dt\">string</span><span class=\"op\">]{}</span></span>\n<span id=\"cb5-4\"><a href=\"#cb5-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    got <span class=\"op\">=</span> <span class=\"bu\">append</span><span class=\"op\">(</span>got<span class=\"op\">,</span> <span class=\"st\">&quot;hello&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb5-5\"><a href=\"#cb5-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    got <span class=\"op\">=</span> <span class=\"bu\">append</span><span class=\"op\">(</span>got<span class=\"op\">,</span> <span class=\"st\">&quot;world&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb5-6\"><a href=\"#cb5-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    want <span class=\"op\">:=</span> group<span class=\"op\">.</span>Group<span class=\"op\">[</span><span class=\"dt\">string</span><span class=\"op\">]{</span><span class=\"st\">&quot;hello&quot;</span><span class=\"op\">,</span> <span class=\"st\">&quot;world&quot;</span><span class=\"op\">}</span></span>\n<span id=\"cb5-7\"><a href=\"#cb5-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>slices<span class=\"op\">.</span>Equal<span class=\"op\">(</span>want<span class=\"op\">,</span> got<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb5-8\"><a href=\"#cb5-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Errorf<span class=\"op\">(</span><span class=\"st\">&quot;want %v, got %v&quot;</span><span class=\"op\">,</span> want<span class=\"op\">,</span> got<span class=\"op\">)</span></span>\n<span id=\"cb5-9\"><a href=\"#cb5-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb5-10\"><a href=\"#cb5-10\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/exercises/group/group_test.go\">Listing\n<code>exercises/group</code></a>)</p>\n<p><strong>GOAL:</strong> Get the test passing!</p>\n<hr />\n<p><strong>HINT:</strong> Well, a “group” is a lot like a “bunch”, and I\ndon’t think you’ll need any more hints than that. There’s no trick here:\nit’s just a confidence builder to get you used to defining generic\ntypes.</p>\n<hr />\n<p><strong>SOLUTION:</strong> And here’s what that looks like, just as\nwe saw before with the <code>Bunch</code> type:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb6-1\"><a href=\"#cb6-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Group<span class=\"op\">[</span>E <span class=\"dt\">any</span><span class=\"op\">]</span> <span class=\"op\">[]</span>E</span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/solutions/group/group.go\">Listing\n<code>solutions/group</code></a>)</p>\n<p>I told you it was easy!</p>\n<h2 id=\"generic-function-types\">Generic function types</h2>\n<p>You probably know that <em>functions are values</em> in Go. That is,\nyou can pass a function as an argument to another function, you can\n<em>return</em> a function from a function, and you can declare\nvariables or struct fields of a particular function type.</p>\n<p>In other words, just as Go values can be integers, floats, or\nstrings, they can also be functions. For example, a function that takes\nan <code>int</code> parameter and returns <code>bool</code> would have\nthe type <code>func(int) bool</code>. This is a very handy feature of\nGo, and we use it a lot.</p>\n<h3 id=\"generic-functions-as-values\">Generic functions as values</h3>\n<p>So what if that function were generic? For example, the\n<code>Identity[T]</code> function in our earlier example. How would we\ndeclare a variable to which we could assign the function\n<code>Identity[T]</code>? What would be the type of such a variable?</p>\n<p>Well, you now know that there’s actually no such function as\n<code>Identity[T]</code>, only one or more <em>instantiations</em> of\nthat function on a specific type, such as <code>string</code>. As we’ve\nseen, the <code>Identity[T]</code> function definition is just a kind of\n“stencil” that Go uses to produce <em>actual</em> functions.</p>\n<p>So there <em>is</em> such a function as\n<code>Identity[string]</code>, and accordingly we can use it as a value.\nFor example, we can assign it to a variable:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb7-1\"><a href=\"#cb7-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>f <span class=\"op\">:=</span> Identity<span class=\"op\">[</span><span class=\"dt\">string</span><span class=\"op\">]</span></span></code></pre>\n<h3 id=\"the-type-is-always-instantiated\">The type is always\ninstantiated</h3>\n<p>What is the type of the variable <code>f</code>, then? Well, it’s\nwhatever the type of <code>Identity[string]</code> is. Here’s the\nsignature of the generic <code>Identity</code> function again:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb8-1\"><a href=\"#cb8-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Identity<span class=\"op\">[</span>T <span class=\"dt\">any</span><span class=\"op\">](</span>v T<span class=\"op\">)</span> T <span class=\"op\">{</span></span></code></pre>\n<p>So if T is <code>string</code> in this case, then we feel the type of\n<code>Identity[string]</code> should be:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb9-1\"><a href=\"#cb9-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span><span class=\"op\">(</span><span class=\"dt\">string</span><span class=\"op\">)</span> <span class=\"dt\">string</span></span></code></pre>\n<p>Let’s ask Go itself. Conveniently, the <code>fmt</code> package can\nreport the type of a value, using the <code>%T</code> verb. So we’ll see\nwhat type it thinks <code>f</code> is in this case:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb10-1\"><a href=\"#cb10-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>f <span class=\"op\">:=</span> Identity<span class=\"op\">[</span><span class=\"dt\">string</span><span class=\"op\">]</span></span>\n<span id=\"cb10-2\"><a href=\"#cb10-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>fmt<span class=\"op\">.</span>Printf<span class=\"op\">(</span><span class=\"st\">&quot;%T</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span><span class=\"op\">,</span> f<span class=\"op\">)</span></span>\n<span id=\"cb10-3\"><a href=\"#cb10-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// Output:</span></span>\n<span id=\"cb10-4\"><a href=\"#cb10-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// func(string) string</span></span></code></pre>\n<p>How straightforward!</p>\n<h3 id=\"there-are-no-generic-functions\">There are no generic\nfunctions</h3>\n<p>Just as with generic types, then, <em>there are no generic functions\nin Go</em>, if you want to be a smart-alec about it (and I do).</p>\n<p>Any generic functions you may write will in fact be instantiated on\nsome specific type at compile time, and they will then just be plain old\nfunctions, like <code>func(string) string</code>. If we wanted to give\nsuch a specific function type a name, we could:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb11-1\"><a href=\"#cb11-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Stringulator <span class=\"kw\">func</span><span class=\"op\">(</span><span class=\"dt\">string</span><span class=\"op\">)</span> <span class=\"dt\">string</span></span></code></pre>\n<p>Could we define a <em>generic function type</em>, though? That is,\ngive a name to the type of a generic function on some arbitrary type\nT.</p>\n<p>For example, could we write something like:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb12-1\"><a href=\"#cb12-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> idFunc <span class=\"kw\">func</span><span class=\"op\">[</span>T <span class=\"dt\">any</span><span class=\"op\">](</span>T<span class=\"op\">)</span> T</span>\n<span id=\"cb12-2\"><a href=\"#cb12-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// syntax error: function type must have no type parameters</span></span></code></pre>\n<p>Nope. If you think about it, how could Go compile this? It couldn’t,\nbecause <em>all type arguments must be known at compile time</em>.</p>\n<p>What we <em>can</em> write is this:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb13-1\"><a href=\"#cb13-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> idFunc<span class=\"op\">[</span>T <span class=\"dt\">any</span><span class=\"op\">]</span> <span class=\"kw\">func</span><span class=\"op\">(</span>T<span class=\"op\">)</span> T</span></code></pre>\n<p>This is fine, because it’s a <em>generic type</em>, just like the\nones we’ve already seen. For some T, we’re saying, an\n<code>idFunc[T]</code> is a function that takes a T and returns a T.</p>\n<p>If this is ever instantiated in our program, it will become some\nspecific type like <code>func(int) int</code>. If not, Go can safely\nignore it. Either way, no unknown types are involved.</p>\n<h2 id=\"generic-types-as-function-parameters\">Generic types as function\nparameters</h2>\n<p>We can create both generic functions and generic types, as we’ve\nseen. So an interesting question occurs: could we write a generic\nfunction that takes a <em>parameter</em> of a generic type?</p>\n<p>The answer is absolutely yes:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb14-1\"><a href=\"#cb14-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> PrintBunch<span class=\"op\">[</span>E <span class=\"dt\">any</span><span class=\"op\">](</span>v Bunch<span class=\"op\">[</span>E<span class=\"op\">])</span> <span class=\"op\">{</span></span>\n<span id=\"cb14-2\"><a href=\"#cb14-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    fmt<span class=\"op\">.</span>Println<span class=\"op\">(</span>v<span class=\"op\">)</span></span>\n<span id=\"cb14-3\"><a href=\"#cb14-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb14-4\"><a href=\"#cb14-4\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb14-5\"><a href=\"#cb14-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> main<span class=\"op\">()</span> <span class=\"op\">{</span></span>\n<span id=\"cb14-6\"><a href=\"#cb14-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    b <span class=\"op\">:=</span> Bunch<span class=\"op\">[</span><span class=\"dt\">int</span><span class=\"op\">]{</span><span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">,</span> <span class=\"dv\">3</span><span class=\"op\">}</span></span>\n<span id=\"cb14-7\"><a href=\"#cb14-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    PrintBunch<span class=\"op\">(</span>b<span class=\"op\">)</span></span>\n<span id=\"cb14-8\"><a href=\"#cb14-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"co\">// Output:</span></span>\n<span id=\"cb14-9\"><a href=\"#cb14-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"co\">// [1, 2, 3]</span></span>\n<span id=\"cb14-10\"><a href=\"#cb14-10\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>This is pretty exciting stuff! But there’s a limit to what we can do\nwith generic functions that take literally <em>any</em> type. We’ll see\nwhat that limit is in a moment, but first, let’s do a little more\nconfidence building.</p>\n<h3 id=\"exercise-lengthy-proceedings\">Exercise: Lengthy proceedings</h3>\n<p>Now it’s your turn to write a generic function on a generic type, to\nsolve the <a href=\"https://github.com/bitfield/know-go/tree/main/exercises/length\"><code>length</code></a>\nexercise.</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb15-1\"><a href=\"#cb15-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestLenOfSliceIs2WhenItContains2Elements<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb15-2\"><a href=\"#cb15-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb15-3\"><a href=\"#cb15-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    s <span class=\"op\">:=</span> <span class=\"op\">[]</span><span class=\"dt\">int</span><span class=\"op\">{</span><span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">}</span></span>\n<span id=\"cb15-4\"><a href=\"#cb15-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    want <span class=\"op\">:=</span> <span class=\"dv\">2</span></span>\n<span id=\"cb15-5\"><a href=\"#cb15-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    got <span class=\"op\">:=</span> length<span class=\"op\">.</span>Len<span class=\"op\">(</span>s<span class=\"op\">)</span></span>\n<span id=\"cb15-6\"><a href=\"#cb15-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> want <span class=\"op\">!=</span> got <span class=\"op\">{</span></span>\n<span id=\"cb15-7\"><a href=\"#cb15-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Errorf<span class=\"op\">(</span><span class=\"st\">&quot;Len(%v): want %d, got %d&quot;</span><span class=\"op\">,</span> s<span class=\"op\">,</span> want<span class=\"op\">,</span> got<span class=\"op\">)</span></span>\n<span id=\"cb15-8\"><a href=\"#cb15-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb15-9\"><a href=\"#cb15-9\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/exercises/length/length_test.go\">Listing\n<code>exercises/length</code></a>)</p>\n<p><strong>GOAL:</strong> Your task is to implement a generic function\n<code>Len[E]</code> that returns the length of a given slice. As usual,\nthe test will tell you when you’ve got it right!</p>\n<hr />\n<p><strong>HINT:</strong> Actually, the <em>implementation</em> is easy,\nisn’t it? We don’t need to write code to figure out the length of some\nslice; there’s a built-in function for that (see if you can guess which\none).</p>\n<p>The tricky bit, if it is tricky, might be writing the\n<em>signature</em> of the <code>Len</code> function. But it’s not really\nany more complicated than what we’ve seen already.</p>\n<p>For example, the <code>PrintBunch</code> function takes a\n<code>Bunch[E]</code> for some arbitrary element type E. Well, so does\nthis one! Can you see what to do?</p>\n<hr />\n<p><strong>SOLUTION:</strong> Here’s one possible answer:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb16-1\"><a href=\"#cb16-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Len<span class=\"op\">[</span>E <span class=\"dt\">any</span><span class=\"op\">](</span>s <span class=\"op\">[]</span>E<span class=\"op\">)</span> <span class=\"dt\">int</span> <span class=\"op\">{</span></span>\n<span id=\"cb16-2\"><a href=\"#cb16-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> <span class=\"bu\">len</span><span class=\"op\">(</span>s<span class=\"op\">)</span></span>\n<span id=\"cb16-3\"><a href=\"#cb16-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/solutions/length/length.go\">Listing\n<code>solutions/length</code></a>)</p>\n<h2 id=\"constraining-type-parameters\">Constraining type parameters</h2>\n<p>We saw in the <a href=\"https://bitfieldconsulting.com/posts/type-parameters\">previous tutorial</a>\nthat one of the limitations of interface types in Go is that we can’t\nuse them with operators such as <code>+</code>. Remember our\n<code>AddAnything</code> example?</p>\n<h3 id=\"we-cant-add-any-to-any\">We can’t add <code>any</code> to\n<code>any</code></h3>\n<p>You might be wondering if the same kind of limitation applies to\nfunctions parameterised by <code>T any</code>, and indeed it does. If we\ntry to write a generic <code>AddAnything[T any]</code>, for example,\nthat doesn’t work:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb17-1\"><a href=\"#cb17-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> AddAnything<span class=\"op\">[</span>T <span class=\"dt\">any</span><span class=\"op\">](</span>x<span class=\"op\">,</span> y T<span class=\"op\">)</span> T <span class=\"op\">{</span></span>\n<span id=\"cb17-2\"><a href=\"#cb17-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> x <span class=\"op\">+</span> y</span>\n<span id=\"cb17-3\"><a href=\"#cb17-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb17-4\"><a href=\"#cb17-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// invalid operation: operator + not defined on x (variable</span></span>\n<span id=\"cb17-5\"><a href=\"#cb17-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// of type T constrained by any)</span></span></code></pre>\n<p>Go is always right, but it can sometimes express itself in a rather\nterse way, so let’s unpack that error message a little.</p>\n<p>It’s complaining about this line:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb18-1\"><a href=\"#cb18-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"cf\">return</span> x <span class=\"op\">+</span> y</span></code></pre>\n<p>And it’s saying:</p>\n<pre><code>operator + not defined on x</code></pre>\n<p>To put it another way, Go has no way to guarantee that whatever\nspecific type T happens to be when the function is instantiated, that\ntype will work with the <code>+</code> operator.</p>\n<p>It <em>might</em>, but then again, it might not, because:</p>\n<pre><code>variable of type T constrained by any</code></pre>\n<h3 id=\"not-every-type-is-addable\">Not every type is “addable”</h3>\n<p>In other words, because <code>x</code> can be <em>any</em> type,\nthere’s no way to guarantee that, when the program runs, <code>x</code>\nwill be one of the types that supports the <code>+</code> operator. So\nthis is just the same kind of problem as when we tried to add together\ntwo <code>any</code> values.</p>\n<p>If <code>x</code> and <code>y</code> were some struct type, for\nexample, that certainly wouldn’t work: structs don’t support\n<code>+</code>, because it’s not meaningful to add two structs together.\nThe <code>+</code> operator isn’t <em>defined</em> on structs, we\nsay.</p>\n<p>Go is telling us that we can’t write the expression\n<code>x + y</code> with values of literally <em>any</em> type T: that’s\ntoo broad a range of possible types.</p>\n<p>It might be that, in a given program, we only ever instantiate\n<code>AddAnything</code> on types that <em>do</em> happen to support\n<code>+</code>, such as <code>int</code> or <code>string</code>. But\nthat’s not good enough for Go: we need to <em>guarantee</em> that it\ncan’t be instantiated on some inappropriate type.</p>\n<p>To do this, we need to <em>constrain</em> T a little more. That is,\nto restrict the allowed possibilities for T to only those types that\nsupport the operator we want to use. And we’ll see how to do that in the\nnext post.</p>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Constraints in Go",
      "url": "https://bitfieldconsulting.com/posts/constraints",
      "date": 1730363880,
      "author": "John Arundel",
      "unread": true,
      "desc": "",
      "content": "<figure class=\"\n              sqs-block-image-figure\n              intrinsic\n            \"\n        >\n          \n        \n        \n\n        \n          \n            \n          \n            \n                \n                \n                \n                \n                \n                \n                \n                <img data-stretch=\"false\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png\" data-image-dimensions=\"400x400\" data-image-focal-point=\"0.5,0.5\" alt=\"\" data-load=\"false\" elementtiming=\"system-image-block\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=1000w\" width=\"400\" height=\"400\" sizes=\"(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw\" onload=\"this.classList.add(&quot;loaded&quot;)\" srcset=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/2262dafd-1b89-46f2-8642-6129983c7160/generics-fish.png?format=2500w 2500w\" loading=\"lazy\" decoding=\"async\" data-loader=\"sqs\">\n\n            \n          \n        \n          \n        \n\n        \n      \n        </figure>\n      \n\n    \n  \n\n\n  \n\n\n\n\n\n  <p class=\"\">From <a href=\"https://bitfieldconsulting.com/books/generics\" target=\"_blank\"><em>Know Go</em></a></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n<blockquote>\n<p><em>Design is the beauty of turning constraints into\nadvantages.</em><br />\n—<a href=\"https://talks.ui-patterns.com/videos/design-is-the-beauty-of-turning-constraints-into-advantages-aza-raskin\">Aza\nRaskin</a> </p>\n</blockquote>\n<p>This is the fourth in a four-part series of tutorials on generics in\nGo.</p>\n<ol type=\"1\">\n<li><a href=\"https://bitfieldconsulting.com/posts/generics\">Generics</a></li>\n<li><a href=\"https://bitfieldconsulting.com/posts/type-parameters\">Type parameters</a></li>\n<li><a href=\"https://bitfieldconsulting.com/posts/generic-types\">Generic types</a></li>\n<li><strong>Constraints</strong></li>\n</ol>\n<hr />\n<p>In my book <a href=\"https://bitfieldconsulting.com/books/generics\">Know Go</a>, and in the previous\ntutorials in this series, you’ll learn all about generic programming in\nGo and the new universe of programs it opens up to us. Ironically, one\nof the new features of Go that gives us the most freedom is\n<em>constraints</em>. Let’s talk about that, and explain the\nparadox.</p>\n<p>We saw in the <a href=\"https://bitfieldconsulting.com/posts/generic-types\">previous tutorial</a>\nthat when we’re writing generic functions that take any type, the range\nof things we can <em>do</em> with values of that type is necessarily\nrather limited. For example, we can’t add them together. For that, we’d\nneed to be able to prove to Go that they’re one of the types that\nsupport the <code>+</code> operator.</p>\n<h2 id=\"method-set-constraints\">Method set constraints</h2>\n<p>It’s the same with interfaces, as we discussed in the <a href=\"https://bitfieldconsulting.com/posts/generics\">first post</a> in this series. The empty\ninterface, <code>any</code>, is implemented by every type, and so\nknowing that something implements <code>any</code> tells you nothing\ndistinctive about it.</p>\n<h3 id=\"limitations-of-the-any-constraint\">Limitations of the\n<code>any</code> constraint</h3>\n<p>Similarly, in a generic function parameterised by some type T,\nconstraining T to <code>any</code> doesn’t give Go any information about\nit. So it has no way to guarantee that a given operator, such as\n<code>+</code>, will work with values of T.</p>\n<p>A Go proverb says:</p>\n<blockquote>\n<p><em>The bigger the interface, the weaker the abstraction.</em><br />\n—<a href=\"https://go-proverbs.github.io/\">https://go-proverbs.github.io/</a></p>\n</blockquote>\n<p>And the same is true of constraints. The broader the constraint, and\nthus the more types it allows, the less we can guarantee about what\noperations we can do on them.</p>\n<p>There <em>are</em> a few things we can do with <code>any</code>\nvalues, as you already know, because we’ve done them. For example, we\ncan declare variables of that type, we can assign values to them, we can\nreturn them from functions, and so on.</p>\n<p>But we can’t really do a whole lot of <em>computation</em> with them,\nbecause we can’t use operators like <code>+</code> or <code>-</code>. So\nin order to be able to do something useful with values of T, such as\nadding them, we need more restrictive constraints.</p>\n<p>What kinds of constraints <em>could</em> there be on T? Let’s examine\nthe possibilities.</p>\n<h3 id=\"basic-interfaces\">Basic interfaces</h3>\n<p>One kind of constraint that we’re already familiar with in Go is an\n<em>interface</em>. In fact, all constraints are interfaces of a kind,\nbut let’s use the term <em>basic</em> interface here to avoid any\nconfusion. A basic interface, we’ll say, is one that contains only\nmethod elements.</p>\n<p>For example, the <code>fmt.Stringer</code> interface we saw in the <a href=\"https://bitfieldconsulting.com/posts/generics\">first tutorial</a>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Stringer <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    String<span class=\"op\">()</span> <span class=\"dt\">string</span></span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>We’ve seen that we can write an ordinary, non-generic function that\ntakes a parameter of type <code>Stringer</code>. And we can also use\nthis interface as a type constraint for a generic function.</p>\n<p>For example, we could write a generic function parameterised by some\ntype T, but this time T can’t be just any type. Instead, we’ll say that\nwhatever T turns out to be, it must implement the\n<code>fmt.Stringer</code> interface:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb2-1\"><a href=\"#cb2-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Stringify<span class=\"op\">[</span>T fmt<span class=\"op\">.</span>Stringer<span class=\"op\">](</span>s T<span class=\"op\">)</span> <span class=\"dt\">string</span> <span class=\"op\">{</span></span>\n<span id=\"cb2-2\"><a href=\"#cb2-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> s<span class=\"op\">.</span>String<span class=\"op\">()</span></span>\n<span id=\"cb2-3\"><a href=\"#cb2-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>This is clear enough, and it works the same way as the generic\nfunctions we’ve already written. The only new thing is that we used the\nconstraint <code>Stringer</code> instead of <code>any</code>. Now when\nwe actually call this function in a program, we’re only allowed to pass\nit arguments that implement <code>Stringer</code>.</p>\n<p>What would happen, then, if we tried to call <code>Stringify</code>\nwith an argument that <em>doesn’t</em> implement <code>Stringer</code>?\nWe feel instinctively that this shouldn’t work, and it doesn’t:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb3-1\"><a href=\"#cb3-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>fmt<span class=\"op\">.</span>Println<span class=\"op\">(</span>Stringify<span class=\"op\">(</span><span class=\"dv\">1</span><span class=\"op\">))</span></span>\n<span id=\"cb3-2\"><a href=\"#cb3-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// int does not implement Stringer (missing method String)</span></span></code></pre>\n<p>That makes sense. It’s just the same as if we wrote an ordinary,\nnon-generic function that took a parameter of type\n<code>Stringer</code>, as we did in the <a href=\"https://bitfieldconsulting.com/posts/generics\">first\ntutorial</a>.</p>\n<p>There’s no advantage to writing a generic function in this case,\nsince we can use this interface type directly in an ordinary function.\nAll the same, a basic interface—one defined by a set of methods—is a\nvalid constraint for type parameters, and we can use it that way if we\nwant to.</p>\n<h3 id=\"exercise-stringy-beans\">Exercise: Stringy beans</h3>\n<p>Flex your generics muscles a little now, by writing a generic\nfunction constrained by <code>fmt.Stringer</code> to solve the <a href=\"https://github.com/bitfield/know-go/tree/main/exercises/stringy\"><code>stringy</code></a>\nexercise.</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb4-1\"><a href=\"#cb4-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> greeting <span class=\"kw\">struct</span><span class=\"op\">{}</span></span>\n<span id=\"cb4-2\"><a href=\"#cb4-2\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb4-3\"><a href=\"#cb4-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> <span class=\"op\">(</span>greeting<span class=\"op\">)</span> String<span class=\"op\">()</span> <span class=\"dt\">string</span> <span class=\"op\">{</span></span>\n<span id=\"cb4-4\"><a href=\"#cb4-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> <span class=\"st\">&quot;Howdy!&quot;</span></span>\n<span id=\"cb4-5\"><a href=\"#cb4-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb4-6\"><a href=\"#cb4-6\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb4-7\"><a href=\"#cb4-7\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestStringifyTo_PrintsToSuppliedWriter<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb4-8\"><a href=\"#cb4-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb4-9\"><a href=\"#cb4-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>    buf <span class=\"op\">:=</span> <span class=\"op\">&amp;</span>bytes<span class=\"op\">.</span>Buffer<span class=\"op\">{}</span></span>\n<span id=\"cb4-10\"><a href=\"#cb4-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>    stringy<span class=\"op\">.</span>StringifyTo<span class=\"op\">[</span>greeting<span class=\"op\">](</span>buf<span class=\"op\">,</span> greeting<span class=\"op\">{})</span></span>\n<span id=\"cb4-11\"><a href=\"#cb4-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>    want <span class=\"op\">:=</span> <span class=\"st\">&quot;Howdy!</span><span class=\"ch\">\\n</span><span class=\"st\">&quot;</span></span>\n<span id=\"cb4-12\"><a href=\"#cb4-12\" aria-hidden=\"true\" tabindex=\"-1\"></a>    got <span class=\"op\">:=</span> buf<span class=\"op\">.</span>String<span class=\"op\">()</span></span>\n<span id=\"cb4-13\"><a href=\"#cb4-13\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> want <span class=\"op\">!=</span> got <span class=\"op\">{</span></span>\n<span id=\"cb4-14\"><a href=\"#cb4-14\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Errorf<span class=\"op\">(</span><span class=\"st\">&quot;want %q, got %q&quot;</span><span class=\"op\">,</span> want<span class=\"op\">,</span> got<span class=\"op\">)</span></span>\n<span id=\"cb4-15\"><a href=\"#cb4-15\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb4-16\"><a href=\"#cb4-16\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/exercises/stringy/stringy_test.go\">Listing\n<code>exercises/stringy</code></a>)</p>\n<p><strong>GOAL:</strong> Your job here is to write a generic function\n<code>StringifyTo[T]</code> that takes an <code>io.Writer</code> and a\nvalue of some arbitrary type constrained by <code>fmt.Stringer</code>,\nand prints the value to the writer.</p>\n<hr />\n<p><strong>HINT:</strong> This is a bit like the\n<code>PrintAnything</code> function we saw before, isn’t it? Actually,\nit’s a “print anything stringable” function. We already know what the\nconstraint is (<code>fmt.Stringer</code>), and the rest is\nstraightforward.</p>\n<hr />\n<p><strong>SOLUTION:</strong> Here’s a version that would work, for\nexample:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb5-1\"><a href=\"#cb5-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> StringifyTo<span class=\"op\">[</span>T fmt<span class=\"op\">.</span>Stringer<span class=\"op\">](</span>w io<span class=\"op\">.</span>Writer<span class=\"op\">,</span> p T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb5-2\"><a href=\"#cb5-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    fmt<span class=\"op\">.</span>Fprintln<span class=\"op\">(</span>w<span class=\"op\">,</span> p<span class=\"op\">.</span>String<span class=\"op\">())</span></span>\n<span id=\"cb5-3\"><a href=\"#cb5-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/solutions/stringy/stringy.go\">Listing\n<code>solutions/stringy</code></a>)</p>\n<p>Strictly speaking, of course, we don’t really need to call the\n<code>String</code> method: <code>fmt</code> already knows how to do\nthat automagically. But if we just passed <code>p</code> directly, we\nwouldn’t need the <code>Stringer</code> constraint, and we could use\n<code>any</code>… but what would be the fun in that?</p>\n<h2 id=\"type-set-constraints\">Type set constraints</h2>\n<p>We’ve seen that one way an interface can specify an allowed range of\ntypes is by including a <em>method element</em>, such as\n<code>String() string</code>. That would be a basic interface, but now\nlet’s introduce another kind of interface. Instead of listing methods\nthat the type must have, it directly specifies a set of types that are\nallowed.</p>\n<h3 id=\"type-elements\">Type elements</h3>\n<p>For example, suppose we wanted to write some generic function\n<code>Double</code> that multiplies a number by two, and we want a type\nconstraint that allows only values of type <code>int</code>. We know\nthat <code>int</code> has no methods, so we can’t use any basic\ninterface as a constraint. How can we write it, then?</p>\n<p>Well, here’s how:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb6-1\"><a href=\"#cb6-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> OnlyInt <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb6-2\"><a href=\"#cb6-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"dt\">int</span></span>\n<span id=\"cb6-3\"><a href=\"#cb6-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>Very straightforward! It looks just like a regular interface\ndefinition, except that instead of method elements, it contains a single\n<em>type element</em>, consisting of a named type. In this case, the\nnamed type is <code>int</code>.</p>\n<h3 id=\"using-a-type-set-constraint\">Using a type set constraint</h3>\n<p>How would we use a constraint like this? Let’s write\n<code>Double</code>, then:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb7-1\"><a href=\"#cb7-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Double<span class=\"op\">[</span>T OnlyInt<span class=\"op\">](</span>v T<span class=\"op\">)</span> T <span class=\"op\">{</span></span>\n<span id=\"cb7-2\"><a href=\"#cb7-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> v <span class=\"op\">*</span> <span class=\"dv\">2</span></span>\n<span id=\"cb7-3\"><a href=\"#cb7-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>In other words, for some T that satisfies the constraint\n<code>OnlyInt</code>, <code>Double</code> takes a T parameter and\nreturns a T result.</p>\n<p>Note that we now have one answer to the sort of problem we\nencountered with <code>AddAnything</code>: how to enable the\n<code>*</code> operator (or any other arithmetic operator) in a\nparameterised function. Since T can only be <code>int</code> (thanks to\nthe <code>OnlyInt</code> constraint), Go can guarantee that the\n<code>*</code> operator will work with T values.</p>\n<p>It’s not the complete answer, though, since there are other types\nthat support <code>*</code> that <em>wouldn’t</em> be allowed by this\nconstraint. And in any case, if we were only going to support\n<code>int</code>, we could have just written an ordinary function that\ntook an <code>int</code> parameter.</p>\n<p>So we’ll need to be able to expand the range of types allowed by our\nconstraint a little, but not beyond the types that support\n<code>*</code>. How can we do that?</p>\n<h3 id=\"unions\">Unions</h3>\n<p>What types <em>can</em> satisfy the constraint <code>OnlyInt</code>?\nWell, only <code>int</code>! To broaden this range, we can create a\nconstraint specifying more than one named type:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb8-1\"><a href=\"#cb8-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Integer <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb8-2\"><a href=\"#cb8-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"dt\">int</span> <span class=\"op\">|</span> <span class=\"dt\">int8</span> <span class=\"op\">|</span> <span class=\"dt\">int16</span> <span class=\"op\">|</span> <span class=\"dt\">int32</span> <span class=\"op\">|</span> <span class=\"dt\">int64</span></span>\n<span id=\"cb8-3\"><a href=\"#cb8-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>The types are separated by the pipe character, <code>|</code>. You\ncan think of this as representing “or”. In other words, a type will\nsatisfy this constraint if it is <code>int</code> <em>or</em>\n<code>int8</code> <em>or</em>… you get the idea.</p>\n<p>This kind of interface element is called a <em>union</em>. The type\nelements in a union can include any Go types, including interface\ntypes.</p>\n<p>It can even include other constraints. In other words, we can\n<em>compose</em> new constraints from existing ones, like this:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb9-1\"><a href=\"#cb9-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Float <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb9-2\"><a href=\"#cb9-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"dt\">float32</span> <span class=\"op\">|</span> <span class=\"dt\">float64</span></span>\n<span id=\"cb9-3\"><a href=\"#cb9-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb9-4\"><a href=\"#cb9-4\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb9-5\"><a href=\"#cb9-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Complex <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb9-6\"><a href=\"#cb9-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"dt\">complex64</span> <span class=\"op\">|</span> <span class=\"dt\">complex128</span></span>\n<span id=\"cb9-7\"><a href=\"#cb9-7\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb9-8\"><a href=\"#cb9-8\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb9-9\"><a href=\"#cb9-9\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Number <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb9-10\"><a href=\"#cb9-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>    Integer <span class=\"op\">|</span> Float <span class=\"op\">|</span> Complex</span>\n<span id=\"cb9-11\"><a href=\"#cb9-11\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>We’re saying that <code>Integer</code>, <code>Float</code>, and\n<code>Complex</code> are all unions of different built-in numeric types,\nbut we’re also creating a new constraint <code>Number</code>, which is a\nunion of those three <em>interface</em> types we just defined. If it’s\nan integer, a float, or a complex number, then it’s a number!</p>\n<h3 id=\"the-set-of-all-allowed-types\">The set of all allowed types</h3>\n<p>The <em>type set</em> of a constraint is the set of all types that\nsatisfy it. The type set of the empty interface (<code>any</code>) is\nthe set of all types, as you’d expect.</p>\n<p>The type set of a union element (such as <code>Float</code> in the\nprevious example) is the union of the type sets of all its terms.</p>\n<p>In the <code>Float</code> example, which is the union of\n<code>float32 | float64</code>, its type set contains\n<code>float32</code>, <code>float64</code>, and no other types.</p>\n<h3 id=\"intersections\">Intersections</h3>\n<p>You probably know that with a basic interface, a type must have\n<em>all</em> of the methods listed in order to implement the interface.\nAnd if the interface contains other interfaces, a type must implement\n<em>all</em> of those interfaces, not just one of them.</p>\n<p>For example:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb10-1\"><a href=\"#cb10-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> ReaderStringer <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb10-2\"><a href=\"#cb10-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    io<span class=\"op\">.</span>Reader</span>\n<span id=\"cb10-3\"><a href=\"#cb10-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    fmt<span class=\"op\">.</span>Stringer</span>\n<span id=\"cb10-4\"><a href=\"#cb10-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>If we were to write this as an <em>interface literal</em>, we would\nseparate the methods with a semicolon instead of a newline, but the\nmeaning is the same:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb11-1\"><a href=\"#cb11-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">interface</span> <span class=\"op\">{</span> io<span class=\"op\">.</span>Reader<span class=\"op\">;</span> fmt<span class=\"op\">.</span>Stringer <span class=\"op\">}</span></span></code></pre>\n<p>To implement this interface, a type has to implement <em>both</em>\n<code>io.Reader</code> <em>and</em> <code>fmt.Stringer</code>. Just one\nor the other isn’t good enough.</p>\n<p>Each line of an interface definition like this, then, is treated as a\ndistinct type element. The type set of the interface as a whole is the\n<em>intersection</em> of the type sets of all its elements. That is,\nonly those types that all the elements have in common.</p>\n<p>So putting interface elements on different lines has the effect of\nrequiring a type to implement <em>all</em> those elements. We don’t need\nthis kind of interface very often, but we can imagine cases where it\nmight be necessary.</p>\n<h3 id=\"empty-type-sets\">Empty type sets</h3>\n<p>You might be wondering about what happens if we define an interface\nwhose type set is completely empty. That is, if there are no types that\ncan satisfy the constraint.</p>\n<p>Well, that could happen with an intersection of two type sets that\nhave <em>no</em> elements in common. For example:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb12-1\"><a href=\"#cb12-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Unpossible <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb12-2\"><a href=\"#cb12-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"dt\">int</span></span>\n<span id=\"cb12-3\"><a href=\"#cb12-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"dt\">string</span></span>\n<span id=\"cb12-4\"><a href=\"#cb12-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>Clearly no type can be both <code>int</code> and <code>string</code>\nat the same time! Or, to put it another way, this interface’s type set\nis empty.</p>\n<p>If we try to instantiate a function constrained by\n<code>Unpossible</code>, we’ll find, naturally enough, that it can’t be\ndone:</p>\n<pre><code>cannot implement Unpossible (empty type set)</code></pre>\n<p>We probably wouldn’t do this on purpose, since an unsatisfiable\nconstraint doesn’t seem that useful. But with more sophisticated\ninterfaces, we might accidentally reduce the allowed type set to zero,\nand it’s helpful to know what this error message means so that we can\nfix the problem.</p>\n<h2 id=\"composite-type-literals\">Composite type literals</h2>\n<p>A <em>composite</em> type is one that’s built up from other types. We\nsaw some composite types in the <a href=\"https://bitfieldconsulting.com/posts/generic-types\">previous\ntutorial</a>, such as <code>[]E</code>, which is a slice of some element\ntype E.</p>\n<p>But we’re not restricted to defined types with names. We can also\nconstruct new types on the fly, using a <em>type literal</em>: that is,\nliterally writing out the type definition as part of the interface.</p>\n<h3 id=\"a-struct-type-literal\">A struct type literal</h3>\n<p>For example, this interface specifies a <em>struct</em> type\nliteral:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb14-1\"><a href=\"#cb14-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Pointish <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb14-2\"><a href=\"#cb14-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"kw\">struct</span><span class=\"op\">{</span> X<span class=\"op\">,</span> Y <span class=\"dt\">int</span> <span class=\"op\">}</span></span>\n<span id=\"cb14-3\"><a href=\"#cb14-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>A type parameter with this constraint would allow any instance of\nsuch a struct. In other words, its type set contains exactly one type:\n<code>struct{ X, Y int }</code>.</p>\n<h3 id=\"access-to-struct-fields\">Access to struct fields</h3>\n<p>While we can write a generic function constrained by some struct type\nsuch as <code>Pointish</code>, there are limitations on what that\nfunction can do with that type. One is that it can’t access the struct’s\n<em>fields</em>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb15-1\"><a href=\"#cb15-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> GetX<span class=\"op\">[</span>T Pointish<span class=\"op\">](</span>p T<span class=\"op\">)</span> <span class=\"dt\">int</span> <span class=\"op\">{</span></span>\n<span id=\"cb15-2\"><a href=\"#cb15-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> p<span class=\"op\">.</span>X</span>\n<span id=\"cb15-3\"><a href=\"#cb15-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb15-4\"><a href=\"#cb15-4\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// p.X undefined (type T has no field or method X)</span></span></code></pre>\n<p>In other words, we can’t refer to a field on <code>p</code>, even\nthough the function’s constraint explicitly says that any <code>p</code>\nis guaranteed to be a struct with at least the field <code>X</code>.\nThis is a limitation of the Go compiler that has not yet been overcome.\nSorry about that.</p>\n<h2 id=\"some-limitations-of-type-sets\">Some limitations of type\nsets</h2>\n<p>An interface containing type elements can <em>only</em> be used as a\nconstraint on a type parameter. It can’t be used as the type of a\nvariable or parameter declaration, like a basic interface can. That too\nis something that might change in the future, but this is where we are\ntoday.</p>\n<h3 id=\"constraints-versus-basic-interfaces\">Constraints versus basic\ninterfaces</h3>\n<p>What exactly stops us from doing that, though? We already know that\nwe can write functions that take ordinary parameters of some basic\ninterface type such as <code>Stringer</code>. So what happens if we try\nto do the same with an interface containing type elements, such as\n<code>Number</code>?</p>\n<p>Let’s see:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb16-1\"><a href=\"#cb16-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Double<span class=\"op\">(</span>p Number<span class=\"op\">)</span> Number <span class=\"op\">{</span></span>\n<span id=\"cb16-2\"><a href=\"#cb16-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// interface contains type constraints</span></span></code></pre>\n<p>This doesn’t compile, for the reasons we’ve discussed. Some potential\nconfusion arises from the fact that a basic interface can be used as\nboth a regular interface type <em>and</em> a constraint on type\nparameters. But interfaces that contain type elements can only be used\nas constraints.</p>\n<h3 id=\"constraints-are-not-classes\">Constraints are not classes</h3>\n<p>If you have some experience with languages that have <em>classes</em>\n(hierarchies of types), then there’s another thing that might trip you\nup with Go generics: constraints are not classes, and you can’t\ninstantiate a generic function or type on a constraint interface.</p>\n<p>To illustrate, suppose we have some concrete types <code>Cow</code>\nand <code>Chicken</code>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb17-1\"><a href=\"#cb17-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Cow <span class=\"kw\">struct</span><span class=\"op\">{</span> moo <span class=\"dt\">string</span> <span class=\"op\">}</span></span>\n<span id=\"cb17-2\"><a href=\"#cb17-2\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb17-3\"><a href=\"#cb17-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Chicken <span class=\"kw\">struct</span><span class=\"op\">{</span> cluck <span class=\"dt\">string</span> <span class=\"op\">}</span></span></code></pre>\n<p>And suppose we define some interface <code>Animal</code> whose type\nset consists of <code>Cow</code> and <code>Chicken</code>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb18-1\"><a href=\"#cb18-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Animal <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb18-2\"><a href=\"#cb18-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    Cow <span class=\"op\">|</span> Chicken</span>\n<span id=\"cb18-3\"><a href=\"#cb18-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>So far, so good, and suppose we now define a generic type\n<code>Farm</code> as a slice of <code>T Animal</code>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb19-1\"><a href=\"#cb19-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Farm<span class=\"op\">[</span>T Animal<span class=\"op\">]</span> <span class=\"op\">[]</span>T</span></code></pre>\n<p>Since we know the type set of <code>Animal</code> contains exactly\n<code>Cow</code> and <code>Chicken</code>, then either of those types\ncan be used to instantiate <code>Farm</code>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb20-1\"><a href=\"#cb20-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>dairy <span class=\"op\">:=</span> Farm<span class=\"op\">[</span>Cow<span class=\"op\">]{}</span></span>\n<span id=\"cb20-2\"><a href=\"#cb20-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>poultry <span class=\"op\">:=</span> Farm<span class=\"op\">[</span>Chicken<span class=\"op\">]{}</span></span></code></pre>\n<p>What about <code>Animal</code> itself? Could we create a\n<code>Farm[Animal]</code>? No, because there’s no such type as\n<code>Animal</code>. It’s a type <em>constraint</em>, not a type, so\nthis gives an error:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb21-1\"><a href=\"#cb21-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>mixed <span class=\"op\">:=</span> Farm<span class=\"op\">[</span>Animal<span class=\"op\">]{}</span></span>\n<span id=\"cb21-2\"><a href=\"#cb21-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// interface contains type constraints</span></span></code></pre>\n<p>And, as we’ve seen, we also couldn’t use <code>Animal</code> as the\ntype of some variable, or ordinary function parameter. Only basic\ninterfaces can be used this way, not interfaces containing type\nelements.</p>\n<h2 id=\"approximations\">Approximations</h2>\n<p>Let’s return to our earlier definition of an interface\n<code>Integer</code>, consisting of a union of named types.\nSpecifically, the built-in signed integer types:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb22-1\"><a href=\"#cb22-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Integer <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb22-2\"><a href=\"#cb22-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"dt\">int</span> <span class=\"op\">|</span> <span class=\"dt\">int8</span> <span class=\"op\">|</span> <span class=\"dt\">int16</span> <span class=\"op\">|</span> <span class=\"dt\">int32</span> <span class=\"op\">|</span> <span class=\"dt\">int64</span></span>\n<span id=\"cb22-3\"><a href=\"#cb22-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>We know that the type set of this interface contains all the types\nwe’ve named. But what about defined types whose <em>underlying</em> type\nis one of the built-in types?</p>\n<h3 id=\"limitations-of-named-types\">Limitations of named types</h3>\n<p>For example:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb23-1\"><a href=\"#cb23-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> MyInt <span class=\"dt\">int</span></span></code></pre>\n<p>Is <code>MyInt</code> also in the type set of <code>Integer</code>?\nLet’s find out. Suppose we write a generic function that uses this\nconstraint:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb24-1\"><a href=\"#cb24-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Double<span class=\"op\">[</span>T Integer<span class=\"op\">](</span>v T<span class=\"op\">)</span> T <span class=\"op\">{</span></span>\n<span id=\"cb24-2\"><a href=\"#cb24-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> v <span class=\"op\">*</span> <span class=\"dv\">2</span></span>\n<span id=\"cb24-3\"><a href=\"#cb24-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>Can we pass it a <code>MyInt</code> value? We’ll soon know:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb25-1\"><a href=\"#cb25-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>fmt<span class=\"op\">.</span>Println<span class=\"op\">(</span>Double<span class=\"op\">(</span>MyInt<span class=\"op\">(</span><span class=\"dv\">1</span><span class=\"op\">)))</span></span>\n<span id=\"cb25-2\"><a href=\"#cb25-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// MyInt does not implement Integer</span></span></code></pre>\n<p>No. That makes sense, because <code>Integer</code> is a list of named\ntypes, and we can see that <code>MyInt</code> isn’t one of them.</p>\n<p>How can we write an interface that allows not only a set of specific\nnamed types, but also any other types <em>derived</em> from them?</p>\n<h3 id=\"type-approximations\">Type approximations</h3>\n<p>We need a new kind of type element: a <em>type approximation</em>. We\nwrite it using the tilde (<code>~</code>) character:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb26-1\"><a href=\"#cb26-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> ApproximatelyInt <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb26-2\"><a href=\"#cb26-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">~</span><span class=\"dt\">int</span></span>\n<span id=\"cb26-3\"><a href=\"#cb26-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>The type set of <code>~int</code> includes <code>int</code> itself,\nbut also any type whose underlying type is <code>int</code> (for\nexample, <code>MyInt</code>).</p>\n<p>If we rewrite <code>Double</code> to use this constraint, we can pass\nit a <code>MyInt</code>, which is good. Even better, it will accept\n<em>any</em> type, now or in the future, whose underlying type is\n<code>int</code>.</p>\n<h3 id=\"derived-types\">Derived types</h3>\n<p>Approximations are especially useful with struct type elements.\nRemember our <code>Pointish</code> interface?</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb27-1\"><a href=\"#cb27-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Pointish <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb27-2\"><a href=\"#cb27-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"kw\">struct</span><span class=\"op\">{</span> x<span class=\"op\">,</span> y <span class=\"dt\">int</span> <span class=\"op\">}</span></span>\n<span id=\"cb27-3\"><a href=\"#cb27-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>Let’s write a generic function with this constraint:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb28-1\"><a href=\"#cb28-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Plot<span class=\"op\">[</span>T Pointish<span class=\"op\">](</span>p T<span class=\"op\">)</span> <span class=\"op\">{</span></span></code></pre>\n<p>We can pass it values of type <code>struct{ x, y int }</code>, as\nyou’d expect:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb29-1\"><a href=\"#cb29-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>p <span class=\"op\">:=</span> <span class=\"kw\">struct</span><span class=\"op\">{</span> x<span class=\"op\">,</span> y <span class=\"dt\">int</span> <span class=\"op\">}{</span><span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">}</span></span>\n<span id=\"cb29-2\"><a href=\"#cb29-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>Plot<span class=\"op\">(</span>p<span class=\"op\">)</span></span></code></pre>\n<p>But now comes a problem: we can’t pass values of any <em>named</em>\nstruct type, even if the struct definition itself matches the constraint\nperfectly:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb30-1\"><a href=\"#cb30-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Point <span class=\"kw\">struct</span> <span class=\"op\">{</span></span>\n<span id=\"cb30-2\"><a href=\"#cb30-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    x<span class=\"op\">,</span> y <span class=\"dt\">int</span></span>\n<span id=\"cb30-3\"><a href=\"#cb30-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb30-4\"><a href=\"#cb30-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>p <span class=\"op\">:=</span> Point<span class=\"op\">{</span><span class=\"dv\">1</span><span class=\"op\">,</span> <span class=\"dv\">2</span><span class=\"op\">}</span></span>\n<span id=\"cb30-5\"><a href=\"#cb30-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>Plot<span class=\"op\">(</span>p<span class=\"op\">)</span></span>\n<span id=\"cb30-6\"><a href=\"#cb30-6\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// Point does not implement Pointish (possibly missing ~ for</span></span>\n<span id=\"cb30-7\"><a href=\"#cb30-7\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// struct{x int; y int} in constraint Pointish)</span></span></code></pre>\n<p>What’s the problem here? Our constraint allows\n<code>struct{ x, y int }</code>, but <code>Point</code> is <em>not that\ntype</em>. It’s a type <em>derived</em> from it. And, just as with\n<code>MyInt</code>, a derived type is distinct from its underlying\ntype.</p>\n<p>You know now how to solve this problem: use a type approximation! And\nGo is telling us the same thing: “Hint, hint: I think you meant to write\na <code>~</code> in your constraint.”</p>\n<p>If we add that approximation, the type set of our interface expands\nto encompass all types derived from the specified struct, including\n<code>Point</code>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb31-1\"><a href=\"#cb31-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Pointish <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb31-2\"><a href=\"#cb31-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">~</span><span class=\"kw\">struct</span><span class=\"op\">{</span> x<span class=\"op\">,</span> y <span class=\"dt\">int</span> <span class=\"op\">}</span></span>\n<span id=\"cb31-3\"><a href=\"#cb31-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<h3 id=\"exercise-a-first-approximation\">Exercise: A first\napproximation</h3>\n<p>Can you use what you’ve just learned to solve the <a href=\"https://github.com/bitfield/know-go/tree/main/exercises/intish\"><code>intish</code></a>\nchallenge?</p>\n<p>Here you’re provided with a function <code>IsPositive</code>, which\ndetermines whether a given value is greater than zero:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb32-1\"><a href=\"#cb32-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> IsPositive<span class=\"op\">[</span>T Intish<span class=\"op\">](</span>v T<span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">{</span></span>\n<span id=\"cb32-2\"><a href=\"#cb32-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> v <span class=\"op\">&gt;</span> <span class=\"dv\">0</span></span>\n<span id=\"cb32-3\"><a href=\"#cb32-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/exercises/intish/intish.go\">Listing\n<code>exercises/intish</code></a>)</p>\n<p>And there’s a set of accompanying tests that instantiate this\nfunction on some derived type <code>MyInt</code>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb33-1\"><a href=\"#cb33-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> MyInt <span class=\"dt\">int</span></span>\n<span id=\"cb33-2\"><a href=\"#cb33-2\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb33-3\"><a href=\"#cb33-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestIsPositive_IsTrueFor1<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb33-4\"><a href=\"#cb33-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb33-5\"><a href=\"#cb33-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    input <span class=\"op\">:=</span> MyInt<span class=\"op\">(</span><span class=\"dv\">1</span><span class=\"op\">)</span></span>\n<span id=\"cb33-6\"><a href=\"#cb33-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>intish<span class=\"op\">.</span>IsPositive<span class=\"op\">(</span>input<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb33-7\"><a href=\"#cb33-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Errorf<span class=\"op\">(</span><span class=\"st\">&quot;IsPositive(1): want true, got false&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb33-8\"><a href=\"#cb33-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb33-9\"><a href=\"#cb33-9\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb33-10\"><a href=\"#cb33-10\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb33-11\"><a href=\"#cb33-11\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestIsPositive_IsFalseForNegative1<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb33-12\"><a href=\"#cb33-12\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb33-13\"><a href=\"#cb33-13\" aria-hidden=\"true\" tabindex=\"-1\"></a>    input <span class=\"op\">:=</span> MyInt<span class=\"op\">(-</span><span class=\"dv\">1</span><span class=\"op\">)</span></span>\n<span id=\"cb33-14\"><a href=\"#cb33-14\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> intish<span class=\"op\">.</span>IsPositive<span class=\"op\">(</span>input<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb33-15\"><a href=\"#cb33-15\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Errorf<span class=\"op\">(</span><span class=\"st\">&quot;IsPositive(-1): want false, got true&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb33-16\"><a href=\"#cb33-16\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb33-17\"><a href=\"#cb33-17\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb33-18\"><a href=\"#cb33-18\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb33-19\"><a href=\"#cb33-19\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestIsPositive_IsFalseForZero<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb33-20\"><a href=\"#cb33-20\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb33-21\"><a href=\"#cb33-21\" aria-hidden=\"true\" tabindex=\"-1\"></a>    input <span class=\"op\">:=</span> MyInt<span class=\"op\">(</span><span class=\"dv\">0</span><span class=\"op\">)</span></span>\n<span id=\"cb33-22\"><a href=\"#cb33-22\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> intish<span class=\"op\">.</span>IsPositive<span class=\"op\">(</span>input<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb33-23\"><a href=\"#cb33-23\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Errorf<span class=\"op\">(</span><span class=\"st\">&quot;IsPositive(0): want false, got true&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb33-24\"><a href=\"#cb33-24\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb33-25\"><a href=\"#cb33-25\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/exercises/intish/intish_test.go\">Listing\n<code>exercises/intish</code></a>)</p>\n<p><strong>GOAL:</strong> Your task here is to define the\n<code>Intish</code> interface.</p>\n<hr />\n<p><strong>HINT:</strong> A method set won’t work here, because the\n<code>int</code> type <em>has</em> no methods! On the other hand, the\ntype literal <code>int</code> won’t work either, because\n<code>MyInt</code> is not <code>int</code>, it’s a new type derived from\nit.</p>\n<p>What kind of constraint could you use instead? I think you know where\nthis is going, don’t you? If not, have another look at the previous\nsection on type approximations.</p>\n<hr />\n<p><strong>SOLUTION:</strong> It’s not complicated, once you know that a\ntype approximation is required:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb34-1\"><a href=\"#cb34-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Intish <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb34-2\"><a href=\"#cb34-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">~</span><span class=\"dt\">int</span></span>\n<span id=\"cb34-3\"><a href=\"#cb34-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/solutions/intish/intish.go\">Listing\n<code>solutions/intish</code></a>)</p>\n<h2 id=\"interface-literals\">Interface literals</h2>\n<p>Up to now, we’ve always used type parameters with a <em>named</em>\nconstraint, such as <code>Integer</code> (or even just\n<code>any</code>). And we know that those constraints are defined as\ninterfaces. So could we use an <em>interface literal</em> as a type\nconstraint?</p>\n<h3 id=\"syntax-of-an-interface-literal\">Syntax of an interface\nliteral</h3>\n<p>An interface literal, as you probably know, consists of the keyword\n<code>interface</code> followed by curly braces containing (optionally)\nsome interface elements.</p>\n<p>For example, the simplest interface literal is the empty interface,\n<code>interface{}</code>, which is common enough to have its own\npredeclared name, <code>any</code>.</p>\n<p>We should be able to write this empty interface literal wherever\n<code>any</code> is allowed as a type constraint, then:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb35-1\"><a href=\"#cb35-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Identity<span class=\"op\">[</span>T <span class=\"kw\">interface</span><span class=\"op\">{}](</span>v T<span class=\"op\">)</span> T <span class=\"op\">{</span></span></code></pre>\n<p>And so we can. But we’re not restricted to only <em>empty</em>\ninterface literals. We could write an interface literal that contains a\nmethod element, for example:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb36-1\"><a href=\"#cb36-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Stringify<span class=\"op\">[</span>T <span class=\"kw\">interface</span><span class=\"op\">{</span> String<span class=\"op\">()</span> <span class=\"dt\">string</span> <span class=\"op\">}](</span>s T<span class=\"op\">)</span> <span class=\"dt\">string</span> <span class=\"op\">{</span></span>\n<span id=\"cb36-2\"><a href=\"#cb36-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> s<span class=\"op\">.</span>String<span class=\"op\">()</span></span>\n<span id=\"cb36-3\"><a href=\"#cb36-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>This is a little hard to read at first, perhaps. But we’ve already\nseen this exact function before, only in that case it had a\n<em>named</em> constraint <code>Stringer</code>. We’ve simply replaced\nthat name with the corresponding interface literal:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb37-1\"><a href=\"#cb37-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">interface</span><span class=\"op\">{</span> String<span class=\"op\">()</span> <span class=\"dt\">string</span> <span class=\"op\">}</span></span></code></pre>\n<p>That is, the set of types that have a <code>String</code> method. We\ndon’t need to name this interface in order to use it as a constraint,\nand sometimes it’s clearer to write it as a literal.</p>\n<h3 id=\"omitting-the-interface-keyword\">Omitting the\n<code>interface</code> keyword</h3>\n<p>And we’re not limited to just method elements in interface literals\nused as constraints. We can use type elements too:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb38-1\"><a href=\"#cb38-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">[</span>T <span class=\"kw\">interface</span><span class=\"op\">{</span> <span class=\"op\">~</span><span class=\"dt\">int</span> <span class=\"op\">}]</span></span></code></pre>\n<p>Conveniently, in this case we can omit the enclosing\n<code>interface { ... }</code>, and write simply <code>~int</code> as\nthe constraint:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb39-1\"><a href=\"#cb39-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">[</span>T <span class=\"op\">~</span><span class=\"dt\">int</span><span class=\"op\">]</span></span></code></pre>\n<p>For example, we could write some function <code>Increment</code>\nconstrained to types derived from <code>int</code>:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb40-1\"><a href=\"#cb40-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Increment<span class=\"op\">[</span>T <span class=\"op\">~</span><span class=\"dt\">int</span><span class=\"op\">](</span>v T<span class=\"op\">)</span> T <span class=\"op\">{</span></span>\n<span id=\"cb40-2\"><a href=\"#cb40-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> v <span class=\"op\">+</span> <span class=\"dv\">1</span></span>\n<span id=\"cb40-3\"><a href=\"#cb40-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>However, we can only omit the <code>interface</code> keyword when the\nconstraint contains exactly one type element. Multiple elements wouldn’t\nbe allowed, so this doesn’t work:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb41-1\"><a href=\"#cb41-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Increment<span class=\"op\">[</span>T <span class=\"op\">~</span><span class=\"dt\">int</span><span class=\"op\">;</span> <span class=\"op\">~</span><span class=\"dt\">float64</span><span class=\"op\">](</span>v T<span class=\"op\">)</span> T <span class=\"op\">{</span></span>\n<span id=\"cb41-2\"><a href=\"#cb41-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// syntax error: unexpected semicolon in parameter list; possibly </span></span>\n<span id=\"cb41-3\"><a href=\"#cb41-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// missing comma or ]</span></span></code></pre>\n<p>And we can’t omit <code>interface</code> with method elements\neither:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb42-1\"><a href=\"#cb42-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Increment<span class=\"op\">[</span>T String<span class=\"op\">()</span> <span class=\"dt\">string</span><span class=\"op\">](</span>v T<span class=\"op\">)</span> T <span class=\"op\">{</span></span>\n<span id=\"cb42-2\"><a href=\"#cb42-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// syntax error: unexpected ( in parameter list; possibly </span></span>\n<span id=\"cb42-3\"><a href=\"#cb42-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// missing comma or ]</span></span></code></pre>\n<p>And we can only omit <code>interface</code> in a constraint\n<em>literal</em>. We can’t omit it when defining a named constraint. So\nthis doesn’t work, for example:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb43-1\"><a href=\"#cb43-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Intish <span class=\"op\">~</span><span class=\"dt\">int</span></span>\n<span id=\"cb43-2\"><a href=\"#cb43-2\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"co\">// syntax error: unexpected ~ in type declaration</span></span></code></pre>\n<h3 id=\"referring-to-type-parameters\">Referring to type parameters</h3>\n<p>We’ve seen that in certain cases, instead of having to define it\nseparately, we can write a constraint directly as an interface literal.\nSo you might be wondering: can we refer to T inside the interface\nliteral itself? Yes, we can.</p>\n<p>To see why we might need to do that, suppose we wanted to write a\ngeneric function <code>Contains[T]</code>, that takes a slice of T and\ntells you whether or not it contains a given value.</p>\n<p>And suppose that we’ll determine this, for any particular element of\nthe slice, by calling some <code>Equal</code> method on the element.\nThat means we must constrain the function to only types that have a\nsuitable <code>Equal</code> method.</p>\n<p>So the constraint for T is going to be an interface containing the\nmethod <code>Equal(T) bool</code>, let’s say.</p>\n<p>Can we do this? Let’s try:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb44-1\"><a href=\"#cb44-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Contains<span class=\"op\">[</span>T <span class=\"kw\">interface</span><span class=\"op\">{</span> Equal<span class=\"op\">(</span>T<span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">}](</span>s <span class=\"op\">[]</span>T<span class=\"op\">,</span>  v T<span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">{</span></span></code></pre>\n<p>Yes, this is fine. In fact, using an interface literal is the\n<em>only</em> way to write this constraint. We couldn’t have created\nsome <em>named</em> interface type to do the same thing. Why not?</p>\n<p>Let’s see what happens if we try:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb45-1\"><a href=\"#cb45-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> Equaler <span class=\"kw\">interface</span> <span class=\"op\">{</span></span>\n<span id=\"cb45-2\"><a href=\"#cb45-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    Equal<span class=\"op\">(???)</span> <span class=\"dt\">bool</span> <span class=\"co\">// we can&#39;t say &#39;T&#39; here</span></span>\n<span id=\"cb45-3\"><a href=\"#cb45-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>Because the type parameter T is part of the <code>Equal</code> method\nsignature, and we don’t <em>have</em> T here. The only way to refer to T\nis in an interface literal inside a type constraint:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb46-1\"><a href=\"#cb46-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">[</span>T <span class=\"kw\">interface</span><span class=\"op\">{</span> Equal<span class=\"op\">(</span>T<span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">}]</span></span></code></pre>\n<p>At least, we can’t write a <em>specific</em> interface that mentions\nT in its method set. What we’d need here, in fact, is a <em>generic</em>\ninterface, and you’ll learn how to define and use these in my book, <a href=\"https://bitfieldconsulting.com/posts/generics\">Know Go</a>. If these tutorials have given you an\nappetite for generic programming in Go, I think you’ll really enjoy the\nbook—check it out!</p>\n<h3 id=\"exercise-greater-love\">Exercise: Greater love</h3>\n<p>Your turn now to see if you can solve the <a href=\"https://github.com/bitfield/know-go/tree/main/exercises/greater\"><code>greater</code></a>\nexercise.</p>\n<p>You’ve been given the following (incomplete) function:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb47-1\"><a href=\"#cb47-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> IsGreater<span class=\"op\">[</span>T <span class=\"co\">/* Your constraint here! */</span><span class=\"op\">](</span>x<span class=\"op\">,</span> y T<span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">{</span></span>\n<span id=\"cb47-2\"><a href=\"#cb47-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> x<span class=\"op\">.</span>Greater<span class=\"op\">(</span>y<span class=\"op\">)</span></span>\n<span id=\"cb47-3\"><a href=\"#cb47-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/exercises/greater/greater.go\">Listing\n<code>exercises/greater</code></a>)</p>\n<p>This takes two values of some arbitrary type, and compares them by\ncalling the <code>Greater</code> method on the first value, passing it\nthe second value.</p>\n<p>The tests exercise this function by calling it with two values of a\ndefined type <code>MyInt</code>, which has the required\n<code>Greater</code> method.</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb48-1\"><a href=\"#cb48-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> MyInt <span class=\"dt\">int</span></span>\n<span id=\"cb48-2\"><a href=\"#cb48-2\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb48-3\"><a href=\"#cb48-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> <span class=\"op\">(</span>m MyInt<span class=\"op\">)</span> Greater<span class=\"op\">(</span>v MyInt<span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">{</span></span>\n<span id=\"cb48-4\"><a href=\"#cb48-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> m <span class=\"op\">&gt;</span> v</span>\n<span id=\"cb48-5\"><a href=\"#cb48-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb48-6\"><a href=\"#cb48-6\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb48-7\"><a href=\"#cb48-7\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestIsGreater_IsTrueFor2And1<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb48-8\"><a href=\"#cb48-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb48-9\"><a href=\"#cb48-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>greater<span class=\"op\">.</span>IsGreater<span class=\"op\">(</span>MyInt<span class=\"op\">(</span><span class=\"dv\">2</span><span class=\"op\">),</span> MyInt<span class=\"op\">(</span><span class=\"dv\">1</span><span class=\"op\">))</span> <span class=\"op\">{</span></span>\n<span id=\"cb48-10\"><a href=\"#cb48-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Fatalf<span class=\"op\">(</span><span class=\"st\">&quot;IsGreater(2, 1): want true, got false&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb48-11\"><a href=\"#cb48-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb48-12\"><a href=\"#cb48-12\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb48-13\"><a href=\"#cb48-13\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb48-14\"><a href=\"#cb48-14\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestIsGreater_IsFalseFor1And2<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb48-15\"><a href=\"#cb48-15\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb48-16\"><a href=\"#cb48-16\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> greater<span class=\"op\">.</span>IsGreater<span class=\"op\">(</span>MyInt<span class=\"op\">(</span><span class=\"dv\">1</span><span class=\"op\">),</span> MyInt<span class=\"op\">(</span><span class=\"dv\">2</span><span class=\"op\">))</span> <span class=\"op\">{</span></span>\n<span id=\"cb48-17\"><a href=\"#cb48-17\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Fatalf<span class=\"op\">(</span><span class=\"st\">&quot;IsGreater(1, 2): want false, got true&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb48-18\"><a href=\"#cb48-18\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb48-19\"><a href=\"#cb48-19\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/exercises/greater/greater_test.go\">Listing\n<code>exercises/greater</code></a>)</p>\n<p><strong>GOAL:</strong> To make these tests pass, you’ll need to write\nan appropriate type constraint for <code>IsGreater</code>. Can you see\nwhat to do?</p>\n<hr />\n<p><strong>HINT:</strong> Remember, we got here by talking about\nconstraints as interface literals, and in particular, interface literals\nthat refer to the type parameter.</p>\n<p>If you try to define some <em>named</em> interface with the method\nset containing <code>Greater</code>, for example, that won’t work. We\ncan’t do it for the same reason that we couldn’t define a named\ninterface with the method set <code>Equal</code>: we don’t know what\ntype of argument that method takes.</p>\n<p>Just like <code>Equal</code>, <code>Greater</code> takes arguments of\nsome arbitrary type T, so we need an interface literal that can\n<em>refer</em> to T in its definition. Does that help?</p>\n<hr />\n<p><strong>SOLUTION:</strong> Here’s one way to do it:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb49-1\"><a href=\"#cb49-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> IsGreater<span class=\"op\">[</span>T <span class=\"kw\">interface</span><span class=\"op\">{</span> Greater<span class=\"op\">(</span>T<span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">}](</span>x<span class=\"op\">,</span> y T<span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">{</span></span>\n<span id=\"cb49-2\"><a href=\"#cb49-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> x<span class=\"op\">.</span>Greater<span class=\"op\">(</span>y<span class=\"op\">)</span></span>\n<span id=\"cb49-3\"><a href=\"#cb49-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/know-go/blob/main/solutions/greater/greater.go\">Listing\n<code>solutions/greater</code></a>)</p>\n<p>Like most things, it’s delightfully simple once you know. For a type\nparameter T, the required interface is:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb50-1\"><a href=\"#cb50-1\" aria-hidden=\"true\" tabindex=\"-1\"></a>Greater<span class=\"op\">(</span>T<span class=\"op\">)</span> <span class=\"dt\">bool</span></span></code></pre>\n<p>And that’s how we do that.</p>\n<p>Well, I hope you enjoyed this tutorial series, and if so, why not\ntreat yourself to a copy of <a href=\"https://bitfieldconsulting.com/books/generics\">Know Go</a>?\nThere’s much more to explore, so I’d love you to come along with me for\nthe ride.</p>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Rust and Go vs everything else",
      "url": "https://bitfieldconsulting.com/posts/rust-and-go",
      "date": 1732022580,
      "author": "John Arundel",
      "unread": true,
      "desc": "",
      "content": "<figure class=\"\n              sqs-block-image-figure\n              intrinsic\n            \"\n        >\n          \n        \n        \n\n        \n          \n            \n          \n            \n                \n                \n                \n                \n                \n                \n                \n                <img data-stretch=\"false\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png\" data-image-dimensions=\"744x350\" data-image-focal-point=\"0.5,0.5\" alt=\"\" data-load=\"false\" elementtiming=\"system-image-block\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1000w\" width=\"744\" height=\"350\" sizes=\"(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw\" onload=\"this.classList.add(&quot;loaded&quot;)\" srcset=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=2500w 2500w\" loading=\"lazy\" decoding=\"async\" data-loader=\"sqs\">\n\n            \n          \n        \n          \n        \n\n        \n      \n        </figure>\n      \n\n    \n  \n\n\n  \n\n\n\n\n\n  <p class=\"\"><em>Rust and Go make perfect partners</em></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n<p><em>This is an edited version of a recent interview with me by Alex\nPliutau, for his excellent <a href=\"https://packagemain.tech/\">packagemain.tech</a> newsletter.\nThanks, Alex!</em></p>\n<p>Should you Rust, or should you Go? Which language is better, and does\nthat question even make sense? Let’s talk about Go versus Rust in 2024,\nwith our special guest, John Arundel. John is the author of <a href=\"https://bitfieldconsulting.com/books/love\"><em>For the Love of Go</em></a>, <a href=\"https://amzn.to/3O5HFP4\"><em>Cloud Native DevOps with\nKubernetes</em></a>, and many other books [including <a href=\"https://bitfieldconsulting.com/books/rust-tools\"><em>The Secrets of Rust: Tools</em></a>].</p>\n<p>He also teaches both <a href=\"https://bitfieldconsulting.com/courses/learn-go\">Go</a> and <a href=\"https://bitfieldconsulting.com/courses/learn-rust\">Rust</a>, so it’ll be interesting to hear his\nperspective. Here’s the interview!</p>\n<p><strong>John, we seem to be hearing more and more about Rust these\ndays. Can you give us a quick introduction? What is Rust for, and why\ndoes it exist?</strong></p>\n<p>Sure, that’s easy. Rust is a language for controlling elevators.</p>\n<p><strong>Are you kidding?</strong></p>\n<p>Not at all. Graydon Hoare, the originator of Rust, got frustrated\nwhen the elevators in his building kept breaking down due to software\nproblems. He thought “Surely we can do better than this!” And the rest\nis history.</p>\n<p>We can’t prevent all bugs, but we can at least use a programming\nlanguage that eliminates some major categories of bugs, such as buffer\noverflows, data races, and “use after free” issues. So from the very\nbeginning, Rust’s focus has been on building reliable software,\nautomating many of the safety checks that good programmers do anyway,\nand helping to catch mistakes before they reach production.</p>\n<p><strong>That sounds like a good idea, but I get the impression that\nRust is a hard language to learn—especially compared to Go. Is that\nfair, and if so, why?</strong></p>\n<p>Anything’s hard if you learn it the wrong way. In my book <a href=\"https://bitfieldconsulting.com/books/rust-tools\">The Secrets of Rust: Tools</a> I take a\nslightly different approach to most Rust books or tutorials. Instead of\ntrying to tell you everything about Rust <em>the language</em>, which is\na bit much for beginners (and we all start as beginners), the book\nguides you through writing a number of useful <em>programs</em> in\nRust.</p>\n<p>What I’m aiming to show is how much you can do in Rust without even\nknowing about certain features. If you write simple, straightforward\nprograms that glue together existing crates, you can probably solve 80%\nof problems with only about 20% of Rust.</p>\n<p><strong>The “minimum viable Rust” strategy, maybe.</strong></p>\n<p>Exactly! Once you’ve built some confidence in the fundamentals,\nthough, and you’ve started to think the way the Rust compiler thinks,\nyou’ll be ready to meet some more advanced features. As the book goes\non, it introduces neat things like generics, traits, and so on.</p>\n<p>The point is that Rust is a language with lots of features, but you\ndon’t need to use all of them all of the time, and certainly not while\nyou’re learning. If you take this approach, there’s no longer such a big\ndifference between learning Rust and learning Go.</p>\n<p>Go and Rust are both trying, in different ways, to solve the same\nproblem: it’s hard to write software at scale in traditional languages\nlike C and C++, because the programmers have to be very experienced and\nknowledgeable to avoid making mistakes. Even experts can slip up from\ntime to time, and it takes a long time to train programmers to become\nexperts.</p>\n<p>Go tackles this problem by radically simplifying the language:\ncompared to something like C++, it has a lot less syntax to learn. So\nprogrammers can spend their time learning to write programs well, rather\nthan mastering a big, complex language. Go is lean, but effective.</p>\n<p>To use an analogy, it’s easier to learn to drive a tractor than to\nfly a spaceship. The tractor may be a humble, pragmatic machine, but it\ndoes its job perfectly, and it’s actually a better choice than the\nspaceship for many tasks: ploughing a field, for example.</p>\n<p><strong>I like your analogy. I guess Rust would be the\nspaceship?</strong></p>\n<p>Yes, Rust is big, complicated, and powerful, combining many of the\nbest ideas from traditional imperative languages like C with functional\nprogramming concepts borrowed from languages like Haskell and Lisp.</p>\n<p>There’s more to learn in Rust than there is in Go, but then it\n<em>does</em> more! If you want to fly to Mars, a spaceship is a better\nchoice than a tractor. Of course, it takes a little longer to train an\nastronaut than a tractor driver.</p>\n<p><strong>Go has built-in garbage collection, which is great for\nsimplicity. How does memory management work in Rust, and is it a big\nchallenge to learn?</strong></p>\n<p>Yes, garbage collection means you don’t have to worry about\nallocating and freeing memory yourself, as you do in languages like C++.\nThat makes programming easier and eliminates all sorts of memory-related\nbugs. On the other hand, you need a relatively complex runtime, and\ngarbage collection affects performance.</p>\n<p>Rust takes a different approach. It reclaims memory automatically,\nbut without having to pause the program. It can do this by keeping track\nof all the references to a particular piece of data that exist. When no\npart of the program can refer to the data any more, Rust knows that bit\nof memory can be safely recycled straight away.</p>\n<p><strong>Yes, I’ve heard Rust has a strong focus on ownership and\nborrowing. How do these concepts compare to working with pointers in Go,\nand what are some good ways to wrap my head around them?</strong></p>\n<p>Well, I have good news—if you’re already used to <a href=\"https://bitfieldconsulting.com/posts/pointers\">pointers in Go</a>, then references in Rust work\nbasically the same way, only safer. If you create a <em>mutable\nreference</em> to a variable, it works just like a Go pointer: you can\npass it to a function, or store it somewhere.</p>\n<p>But, unlike in Go, as long as that mutable reference exists, it has\nexclusive access to the data: no one else can modify it, or even read\nit. In Go terms, it’s like having an automatic mutex lock. And when a\nfunction doesn’t need to modify the data, it can instead borrow a\n<em>shared</em> reference, which is read-only, and lots of them can\nexist at once.</p>\n<p>Rust also keeps track of the original data: when it goes out of\nscope, any references to it are no longer valid. So the compiler can\ndetect many kinds of <em>dangling pointer</em> bugs where you try to use\na reference to a value that doesn’t exist any more. That results in\nundefined behaviour, which is a nice way of saying that something\nhorrible will happen, and part of Rust’s value proposition is “no\nundefined behaviour—ever”.</p>\n<p>In Rust, then, we have to figure out a way to write our programs so\nthat references to data are always valid, and only one mutable reference\never exists at a time. That takes some getting used to (Rust programmers\ncall it “fighting the borrow checker”), but the resulting programs are\nmore reliable, and more likely to be correct.</p>\n<p>For example, all Go programmers are familiar with <em>data\nraces</em>, where two or more goroutines try to access some shared data\nat the same time, with unpredictable results: at best, the program will\ncrash, and at worst, it will continue with corrupted or invalid\ndata.</p>\n<p>In Rust, a program like this won’t compile! The ownership and\nreference rules mean that two mutable references to the same thing can’t\nexist simultaneously. You just have to solve the problem a different\nway.</p>\n<p><strong>That brings us neatly on to concurrency. I like Go’s\nconcurrency features with channels and goroutines. How does Rust handle\nconcurrency, and are there any similarities I can leverage from my Go\nexperience?</strong></p>\n<p>Yes, goroutines and channels are great: a super-lightweight task\nabstraction that’s very cheap compared to traditional multithreading. On\nthe other hand, Go only gives us the fundamental building blocks: it’s\nup to us to make sure we use them safely, avoiding data races or\ndeadlocks. And that can be hard to do!</p>\n<p>Rust doesn’t have goroutines, but it does have <code>async</code>\ntasks, which are much like goroutines, only with the usual Rust safety\nguarantees. There are also some excellent third-party frameworks such as\nTokio and Rayon that can just take a bunch of data and automatically\nfigure out the most efficient way to crunch it in parallel.</p>\n<p>So, while concurrent programs will always be difficult to write well,\nif you can do it in Go, you’ll find those skills transfer well to Rust,\ntoo.</p>\n<p><strong>I like to learn by doing. Are there any good hands-on\nexercises or projects you’d recommend for a Go programmer getting\nstarted with Rust, like the <a href=\"https://go.dev/tour\">Tour of\nGo</a>, for example?</strong></p>\n<p><a href=\"https://github.com/rust-lang/rustlings\">Rustlings</a> is a\ngreat place to start: it’s a set of interactive bite-size exercises that\nguide you through all the language fundamentals. If you want to get\nfeedback from a real live human, check out the <a href=\"https://exercism.org/tracks/rust/exercises\">Rust track on\nExercism</a>. There’s also <a href=\"https://doc.rust-lang.org/rust-by-example/index.html\">Rust by\nExample</a>, which is a terrific resource for working example\nsnippets.</p>\n<p>All the <a href=\"https://bitfieldconsulting.com/posts/best-rust-books\">best Rust books</a> also\ninclude lots of examples, and <em>Programming Rust</em> in particular is\nfull of interesting code.</p>\n<p><strong>It sounds like you’re a fan of both languages. Which do you\nprefer, and would you recommend that someone who already knows Go should\nalso try learning Rust?</strong></p>\n<p>Yes, Go and Rust each appeal to different parts of my brain. I like\nthe radical simplicity and pragmatism of Go: it does a lot with very\nlittle, and solves most problems pretty well. The language has strong\nopinions about everything, so you don’t have to. Just copy and paste a\nbit of code and you’re basically up and running.</p>\n<p>Rust is even more radical, though, in a different way: its design\nforces you to think more carefully about what you’re doing. The compiler\nconstantly guides you towards a version of your program that’s safer,\nmore efficient, and more likely to be correct. Once you get the hang of\nthinking about problems the Rust way, it’s hard to go back to what you\nwere doing before.</p>\n<p>I think a working knowledge of both Go and Rust is essential for\nanyone who sees themselves as a software engineer in 2024 and beyond.\nThat’s not to say that skills in other languages aren’t still valuable:\nof course they are, and will be for some years yet. But if you’re\nlearning a <em>new</em> language, and that’s always a good idea, Rust\nand Go are great choices for the future. Between them, they neatly cover\nthe whole range of things people want to write programs about.</p>\n<p>Go is perfectly suited for plain, ordinary, everyday software:\ncommand-line tools, business processes, database applications, web\nservices. It’s fairly easy to write Go programs; they build fast, and\nthey run very fast. For probably 80% of the software we write, Go gets\nthe job done just fine.</p>\n<p>Rust, on the other hand, neatly fills the gaps where Go isn’t an\nideal choice: kernels, firmware, embedded devices, real-time systems. It\ngives you all the keys to the hardware, and to ultimate performance. Its\nrelentless focus on memory safety and program correctness make Rust the\nobvious choice for safety-critical applications: industrial, medical,\naerospace.</p>\n<p><strong>And elevators, of course.</strong></p>\n<p>Naturally! So I like that aspect of Rust, and it’s also just a really\nfun and expressive language. It has all the toys! Anyone who got into\nprogramming just for the sheer fun of it will appreciate Rust. A\nwell-written Rust program is a true work of art.</p>\n<p>Don’t be put off by the initial unfamiliarity of the syntax, the\nstruggles with the borrow checker, or the feeling that the compiler has\nit in for you. It’s teaching you a new way of programming, and while\nlearning doesn’t always feel good in the moment, you soon start to feel\nthe benefit of it. Rust has wonderful ergonomics: little things that\nmake life easier for the programmer, like <a href=\"https://bitfieldconsulting.com/posts/rust-errors-option-result\">options and results</a>.</p>\n<p>Even if you decide that Rust isn’t really your thing, you’ll still\nhave learned some interesting new ways of thinking about problems, and\nit certainly also helps you understand more about the different\ntrade-offs that Go makes.</p>\n<p>I wrote a more detailed comparison post about the two languages at <a href=\"https://bitfieldconsulting.com/posts/rust-vs-go/\">Rust vs Go</a>, explaining the different ways\nthat they solve problems, and what sort of tasks each of them excels at.\nAnd I think that from a career point of view, both Go and Rust will be\nvery valuable skills for the foreseeable future. They’re the two\nprogramming languages that I advise everyone to learn first. It’s not\nreally “Rust versus Go”, so much as “Rust <em>and</em> Go versus\neverything else.”</p>\n<p><strong>John, thanks for being our guest, and giving us your\nperspective on Go and Rust. Where can people find out more about you—for\nexample, if they’re interested in your books or training\ncourses?</strong></p>\n<p>It’s my pleasure! Do drop by my website at <a href=\"https://bitfieldconsulting.com/about\">bitfieldconsulting.com</a> if you’d like to know more, or\n<a href=\"https://bitfieldconsulting.com/contact\">get in touch</a>—I’ll be happy to chat.</p>\n&nbsp;\n\n\n\n\n  \n\n  \n\n    \n        \n        \n          <a href=\"https://bitfieldconsulting.com/books/rust-tools\">\n            \n\n            <img class=\"sqs-product-block-main-image\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/82e59084-51d1-4e8d-a6ab-abc411f660cf/cover+%28no+version%29.png\" data-image-dimensions=\"1000x1500\" data-image-focal-point=\"0.5,0.5\" alt=\"The Secrets of Rust: Tools (early access edition)\" data-load=\"false\" elementtiming=\"system-product\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/82e59084-51d1-4e8d-a6ab-abc411f660cf/cover+%28no+version%29.png?format=1000w\" />\n\n            \n              \n            \n          </a>\n\n          \n        \n        \n    \n\n    \n\n      \n\n      \n        \n\n\n\n$34.95\n\n      \n\n      \n\n      \n        \n\n        \n\n        \n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    Add To Cart\n  \n\n      \n\n    \n\n  \n\n\n\n\n&nbsp;",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    }
  ]
}