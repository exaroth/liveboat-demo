{"id":"sML2JBPsdAyCMAUuDAb4rMUzpB9GRgBrSJo6frY3aqUzYMyY1KqfA5MTDk9Bkxae","title":"Blog - Bitfield Consulting","displayTitle":"Dev - Bitfield","url":"https://bitfieldconsulting.com/posts?format=rss","feedLink":"https://bitfieldconsulting.com/posts/","items":[{"title":"Rust and Go vs everything else","url":"https://bitfieldconsulting.com/posts/rust-and-go","date":1732022580,"author":"John Arundel","unread":true,"desc":"","content":"<figure class=\"\n              sqs-block-image-figure\n              intrinsic\n            \"\n        >\n          \n        \n        \n\n        \n          \n            \n          \n            \n                \n                \n                \n                \n                \n                \n                \n                <img data-stretch=\"false\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png\" data-image-dimensions=\"744x350\" data-image-focal-point=\"0.5,0.5\" alt=\"\" data-load=\"false\" elementtiming=\"system-image-block\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1000w\" width=\"744\" height=\"350\" sizes=\"(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw\" onload=\"this.classList.add(&quot;loaded&quot;)\" srcset=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/1632583991063-DG67R13E0S7XK244CSVE/rust-vs-go.png?format=2500w 2500w\" loading=\"lazy\" decoding=\"async\" data-loader=\"sqs\">\n\n            \n          \n        \n          \n        \n\n        \n      \n        </figure>\n      \n\n    \n  \n\n\n  \n\n\n\n\n\n  <p class=\"\"><em>Rust and Go make perfect partners</em></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n<p><em>This is an edited version of a recent interview with me by Alex\nPliutau, for his excellent <a href=\"https://packagemain.tech/\">packagemain.tech</a> newsletter.\nThanks, Alex!</em></p>\n<p>Should you Rust, or should you Go? Which language is better, and does\nthat question even make sense? Let’s talk about Go versus Rust in 2024,\nwith our special guest, John Arundel. John is the author of <a href=\"https://bitfieldconsulting.com/books/love\"><em>For the Love of Go</em></a>, <a href=\"https://amzn.to/3O5HFP4\"><em>Cloud Native DevOps with\nKubernetes</em></a>, and many other books [including <a href=\"https://bitfieldconsulting.com/books/rust-tools\"><em>The Secrets of Rust: Tools</em></a>].</p>\n<p>He also teaches both <a href=\"https://bitfieldconsulting.com/courses/learn-go\">Go</a> and <a href=\"https://bitfieldconsulting.com/courses/learn-rust\">Rust</a>, so it’ll be interesting to hear his\nperspective. Here’s the interview!</p>\n<p><strong>John, we seem to be hearing more and more about Rust these\ndays. Can you give us a quick introduction? What is Rust for, and why\ndoes it exist?</strong></p>\n<p>Sure, that’s easy. Rust is a language for controlling elevators.</p>\n<p><strong>Are you kidding?</strong></p>\n<p>Not at all. Graydon Hoare, the originator of Rust, got frustrated\nwhen the elevators in his building kept breaking down due to software\nproblems. He thought “Surely we can do better than this!” And the rest\nis history.</p>\n<p>We can’t prevent all bugs, but we can at least use a programming\nlanguage that eliminates some major categories of bugs, such as buffer\noverflows, data races, and “use after free” issues. So from the very\nbeginning, Rust’s focus has been on building reliable software,\nautomating many of the safety checks that good programmers do anyway,\nand helping to catch mistakes before they reach production.</p>\n<p><strong>That sounds like a good idea, but I get the impression that\nRust is a hard language to learn—especially compared to Go. Is that\nfair, and if so, why?</strong></p>\n<p>Anything’s hard if you learn it the wrong way. In my book <a href=\"https://bitfieldconsulting.com/books/rust-tools\">The Secrets of Rust: Tools</a> I take a\nslightly different approach to most Rust books or tutorials. Instead of\ntrying to tell you everything about Rust <em>the language</em>, which is\na bit much for beginners (and we all start as beginners), the book\nguides you through writing a number of useful <em>programs</em> in\nRust.</p>\n<p>What I’m aiming to show is how much you can do in Rust without even\nknowing about certain features. If you write simple, straightforward\nprograms that glue together existing crates, you can probably solve 80%\nof problems with only about 20% of Rust.</p>\n<p><strong>The “minimum viable Rust” strategy, maybe.</strong></p>\n<p>Exactly! Once you’ve built some confidence in the fundamentals,\nthough, and you’ve started to think the way the Rust compiler thinks,\nyou’ll be ready to meet some more advanced features. As the book goes\non, it introduces neat things like generics, traits, and so on.</p>\n<p>The point is that Rust is a language with lots of features, but you\ndon’t need to use all of them all of the time, and certainly not while\nyou’re learning. If you take this approach, there’s no longer such a big\ndifference between learning Rust and learning Go.</p>\n<p>Go and Rust are both trying, in different ways, to solve the same\nproblem: it’s hard to write software at scale in traditional languages\nlike C and C++, because the programmers have to be very experienced and\nknowledgeable to avoid making mistakes. Even experts can slip up from\ntime to time, and it takes a long time to train programmers to become\nexperts.</p>\n<p>Go tackles this problem by radically simplifying the language:\ncompared to something like C++, it has a lot less syntax to learn. So\nprogrammers can spend their time learning to write programs well, rather\nthan mastering a big, complex language. Go is lean, but effective.</p>\n<p>To use an analogy, it’s easier to learn to drive a tractor than to\nfly a spaceship. The tractor may be a humble, pragmatic machine, but it\ndoes its job perfectly, and it’s actually a better choice than the\nspaceship for many tasks: ploughing a field, for example.</p>\n<p><strong>I like your analogy. I guess Rust would be the\nspaceship?</strong></p>\n<p>Yes, Rust is big, complicated, and powerful, combining many of the\nbest ideas from traditional imperative languages like C with functional\nprogramming concepts borrowed from languages like Haskell and Lisp.</p>\n<p>There’s more to learn in Rust than there is in Go, but then it\n<em>does</em> more! If you want to fly to Mars, a spaceship is a better\nchoice than a tractor. Of course, it takes a little longer to train an\nastronaut than a tractor driver.</p>\n<p><strong>Go has built-in garbage collection, which is great for\nsimplicity. How does memory management work in Rust, and is it a big\nchallenge to learn?</strong></p>\n<p>Yes, garbage collection means you don’t have to worry about\nallocating and freeing memory yourself, as you do in languages like C++.\nThat makes programming easier and eliminates all sorts of memory-related\nbugs. On the other hand, you need a relatively complex runtime, and\ngarbage collection affects performance.</p>\n<p>Rust takes a different approach. It reclaims memory automatically,\nbut without having to pause the program. It can do this by keeping track\nof all the references to a particular piece of data that exist. When no\npart of the program can refer to the data any more, Rust knows that bit\nof memory can be safely recycled straight away.</p>\n<p><strong>Yes, I’ve heard Rust has a strong focus on ownership and\nborrowing. How do these concepts compare to working with pointers in Go,\nand what are some good ways to wrap my head around them?</strong></p>\n<p>Well, I have good news—if you’re already used to <a href=\"https://bitfieldconsulting.com/posts/pointers\">pointers in Go</a>, then references in Rust work\nbasically the same way, only safer. If you create a <em>mutable\nreference</em> to a variable, it works just like a Go pointer: you can\npass it to a function, or store it somewhere.</p>\n<p>But, unlike in Go, as long as that mutable reference exists, it has\nexclusive access to the data: no one else can modify it, or even read\nit. In Go terms, it’s like having an automatic mutex lock. And when a\nfunction doesn’t need to modify the data, it can instead borrow a\n<em>shared</em> reference, which is read-only, and lots of them can\nexist at once.</p>\n<p>Rust also keeps track of the original data: when it goes out of\nscope, any references to it are no longer valid. So the compiler can\ndetect many kinds of <em>dangling pointer</em> bugs where you try to use\na reference to a value that doesn’t exist any more. That results in\nundefined behaviour, which is a nice way of saying that something\nhorrible will happen, and part of Rust’s value proposition is “no\nundefined behaviour—ever”.</p>\n<p>In Rust, then, we have to figure out a way to write our programs so\nthat references to data are always valid, and only one mutable reference\never exists at a time. That takes some getting used to (Rust programmers\ncall it “fighting the borrow checker”), but the resulting programs are\nmore reliable, and more likely to be correct.</p>\n<p>For example, all Go programmers are familiar with <em>data\nraces</em>, where two or more goroutines try to access some shared data\nat the same time, with unpredictable results: at best, the program will\ncrash, and at worst, it will continue with corrupted or invalid\ndata.</p>\n<p>In Rust, a program like this won’t compile! The ownership and\nreference rules mean that two mutable references to the same thing can’t\nexist simultaneously. You just have to solve the problem a different\nway.</p>\n<p><strong>That brings us neatly on to concurrency. I like Go’s\nconcurrency features with channels and goroutines. How does Rust handle\nconcurrency, and are there any similarities I can leverage from my Go\nexperience?</strong></p>\n<p>Yes, goroutines and channels are great: a super-lightweight task\nabstraction that’s very cheap compared to traditional multithreading. On\nthe other hand, Go only gives us the fundamental building blocks: it’s\nup to us to make sure we use them safely, avoiding data races or\ndeadlocks. And that can be hard to do!</p>\n<p>Rust doesn’t have goroutines, but it does have <code>async</code>\ntasks, which are much like goroutines, only with the usual Rust safety\nguarantees. There are also some excellent third-party frameworks such as\nTokio and Rayon that can just take a bunch of data and automatically\nfigure out the most efficient way to crunch it in parallel.</p>\n<p>So, while concurrent programs will always be difficult to write well,\nif you can do it in Go, you’ll find those skills transfer well to Rust,\ntoo.</p>\n<p><strong>I like to learn by doing. Are there any good hands-on\nexercises or projects you’d recommend for a Go programmer getting\nstarted with Rust, like the <a href=\"https://go.dev/tour\">Tour of\nGo</a>, for example?</strong></p>\n<p><a href=\"https://github.com/rust-lang/rustlings\">Rustlings</a> is a\ngreat place to start: it’s a set of interactive bite-size exercises that\nguide you through all the language fundamentals. If you want to get\nfeedback from a real live human, check out the <a href=\"https://exercism.org/tracks/rust/exercises\">Rust track on\nExercism</a>. There’s also <a href=\"https://doc.rust-lang.org/rust-by-example/index.html\">Rust by\nExample</a>, which is a terrific resource for working example\nsnippets.</p>\n<p>All the <a href=\"https://bitfieldconsulting.com/posts/best-rust-books\">best Rust books</a> also\ninclude lots of examples, and <em>Programming Rust</em> in particular is\nfull of interesting code.</p>\n<p><strong>It sounds like you’re a fan of both languages. Which do you\nprefer, and would you recommend that someone who already knows Go should\nalso try learning Rust?</strong></p>\n<p>Yes, Go and Rust each appeal to different parts of my brain. I like\nthe radical simplicity and pragmatism of Go: it does a lot with very\nlittle, and solves most problems pretty well. The language has strong\nopinions about everything, so you don’t have to. Just copy and paste a\nbit of code and you’re basically up and running.</p>\n<p>Rust is even more radical, though, in a different way: its design\nforces you to think more carefully about what you’re doing. The compiler\nconstantly guides you towards a version of your program that’s safer,\nmore efficient, and more likely to be correct. Once you get the hang of\nthinking about problems the Rust way, it’s hard to go back to what you\nwere doing before.</p>\n<p>I think a working knowledge of both Go and Rust is essential for\nanyone who sees themselves as a software engineer in 2024 and beyond.\nThat’s not to say that skills in other languages aren’t still valuable:\nof course they are, and will be for some years yet. But if you’re\nlearning a <em>new</em> language, and that’s always a good idea, Rust\nand Go are great choices for the future. Between them, they neatly cover\nthe whole range of things people want to write programs about.</p>\n<p>Go is perfectly suited for plain, ordinary, everyday software:\ncommand-line tools, business processes, database applications, web\nservices. It’s fairly easy to write Go programs; they build fast, and\nthey run very fast. For probably 80% of the software we write, Go gets\nthe job done just fine.</p>\n<p>Rust, on the other hand, neatly fills the gaps where Go isn’t an\nideal choice: kernels, firmware, embedded devices, real-time systems. It\ngives you all the keys to the hardware, and to ultimate performance. Its\nrelentless focus on memory safety and program correctness make Rust the\nobvious choice for safety-critical applications: industrial, medical,\naerospace.</p>\n<p><strong>And elevators, of course.</strong></p>\n<p>Naturally! So I like that aspect of Rust, and it’s also just a really\nfun and expressive language. It has all the toys! Anyone who got into\nprogramming just for the sheer fun of it will appreciate Rust. A\nwell-written Rust program is a true work of art.</p>\n<p>Don’t be put off by the initial unfamiliarity of the syntax, the\nstruggles with the borrow checker, or the feeling that the compiler has\nit in for you. It’s teaching you a new way of programming, and while\nlearning doesn’t always feel good in the moment, you soon start to feel\nthe benefit of it. Rust has wonderful ergonomics: little things that\nmake life easier for the programmer, like <a href=\"https://bitfieldconsulting.com/posts/rust-errors-option-result\">options and results</a>.</p>\n<p>Even if you decide that Rust isn’t really your thing, you’ll still\nhave learned some interesting new ways of thinking about problems, and\nit certainly also helps you understand more about the different\ntrade-offs that Go makes.</p>\n<p>I wrote a more detailed comparison post about the two languages at <a href=\"https://bitfieldconsulting.com/posts/rust-vs-go/\">Rust vs Go</a>, explaining the different ways\nthat they solve problems, and what sort of tasks each of them excels at.\nAnd I think that from a career point of view, both Go and Rust will be\nvery valuable skills for the foreseeable future. They’re the two\nprogramming languages that I advise everyone to learn first. It’s not\nreally “Rust versus Go”, so much as “Rust <em>and</em> Go versus\neverything else.”</p>\n<p><strong>John, thanks for being our guest, and giving us your\nperspective on Go and Rust. Where can people find out more about you—for\nexample, if they’re interested in your books or training\ncourses?</strong></p>\n<p>It’s my pleasure! Do drop by my website at <a href=\"https://bitfieldconsulting.com/about\">bitfieldconsulting.com</a> if you’d like to know more, or\n<a href=\"https://bitfieldconsulting.com/contact\">get in touch</a>—I’ll be happy to chat.</p>\n&nbsp;\n\n\n\n\n  \n\n  \n\n    \n        \n        \n          <a href=\"https://bitfieldconsulting.com/books/rust-tools\">\n            \n\n            <img class=\"sqs-product-block-main-image\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/82e59084-51d1-4e8d-a6ab-abc411f660cf/cover+%28no+version%29.png\" data-image-dimensions=\"1000x1500\" data-image-focal-point=\"0.5,0.5\" alt=\"The Secrets of Rust: Tools (early access edition)\" data-load=\"false\" elementtiming=\"system-product\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/82e59084-51d1-4e8d-a6ab-abc411f660cf/cover+%28no+version%29.png?format=1000w\" />\n\n            \n              \n            \n          </a>\n\n          \n        \n        \n    \n\n    \n\n      \n\n      \n        \n\n\n\n$34.95\n\n      \n\n      \n\n      \n        \n\n        \n\n        \n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    Add To Cart\n  \n\n      \n\n    \n\n  \n\n\n\n\n&nbsp;","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Suite smells: undertesting and overtesting","url":"https://bitfieldconsulting.com/posts/undertesting-overtesting","date":1733653380,"author":"John Arundel","unread":true,"desc":"","content":"<figure class=\"\n              sqs-block-image-figure\n              intrinsic\n            \"\n        >\n          \n        \n        \n\n        \n          \n            \n          \n            \n                \n                \n                \n                \n                \n                \n                \n                <img data-stretch=\"false\" data-image=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png\" data-image-dimensions=\"350x350\" data-image-focal-point=\"0.5,0.5\" alt=\"\" data-load=\"false\" elementtiming=\"system-image-block\" src=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png?format=1000w\" width=\"350\" height=\"350\" sizes=\"(max-width: 640px) 100vw, (max-width: 767px) 100vw, 100vw\" onload=\"this.classList.add(&quot;loaded&quot;)\" srcset=\"https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png?format=100w 100w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png?format=300w 300w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png?format=500w 500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png?format=750w 750w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png?format=1000w 1000w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png?format=1500w 1500w, https://images.squarespace-cdn.com/content/v1/5e10bdc20efb8f0d169f85f9/e123ae8e-7a4d-469b-b5ca-c2f8f14a0ced/bug.png?format=2500w 2500w\" loading=\"lazy\" decoding=\"async\" data-loader=\"sqs\">\n\n            \n          \n        \n          \n        \n\n        \n      \n        </figure>\n      \n\n    \n  \n\n\n  \n\n\n\n\n\n  <p class=\"\"><em>From </em><a href=\"https://bitfieldconsulting.com/books/tests\"><em>The Power of Go: Tests</em></a></p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n<blockquote>\n<p><em>It is tempting to test that the code does what it should do and\nleave it at that, but it’s arguably even more important to test that it\ndoesn’t do what it shouldn’t do.</em><br />\n—Mike Bland, <a href=\"https://martinfowler.com/articles/testing-culture.html\">“Goto\nFail, Heartbleed, and Unit Testing Culture”</a></p>\n</blockquote>\n<p><a href=\"https://bitfieldconsulting.com/books/tests\">The Power of Go: Tests</a> is a compilation of\nall the lessons I’ve learned over a lifetime of software engineering:\nit’s about how to write robust, reliable, and above all <em>correct</em>\nprograms.</p>\n<p>This is the second in a three-part series of excerpts from the book,\nfocusing on test suites in Go, what kind of problems you might find with\nthem, and some tips on how to fix them.</p>\n<ol type=\"1\">\n<li><a href=\"https://bitfieldconsulting.com/posts/testing-legacy-code\">Testing legacy code</a></li>\n<li><strong>Undertesting and overtesting</strong></li>\n<li>Slow, flaky, and failing (<em>coming soon</em>)</li>\n</ol>\n<hr />\n<p>In the <a href=\"https://bitfieldconsulting.com/posts/testing-legacy-code\">first post</a>, we talked\nabout what to do if your codebase has no tests at all, or not enough\ntests. Today, let’s look at the tests you have, and what might be wrong\nwith them.</p>\n<p>Even when a certain piece of code is nominally <em>covered</em> by\nsome test, is it really tested? That’s not always a given. In other\nwords, just because a test causes some function to be executed, that\ndoesn’t mean it shows that the function <em>does</em> the right thing.\nFor that we need to look more closely at the test. Is it too\noptimistic?</p>\n<h2 id=\"optimistic-tests\">Optimistic tests</h2>\n<p>An optimistic test is designed only to confirm that the system works,\nnot to prove that it doesn’t.</p>\n<p>Surprisingly, one problem that optimistic tests can miss is when the\nsystem does <em>nothing at all</em>.</p>\n<p>For example, consider a test for some function\n<code>user.Create</code>, like this:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb1-1\"><a href=\"#cb1-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestCreateCreatesGivenUser<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb1-2\"><a href=\"#cb1-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb1-3\"><a href=\"#cb1-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Create<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb1-4\"><a href=\"#cb1-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb1-5\"><a href=\"#cb1-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Alice not created&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb1-6\"><a href=\"#cb1-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb1-7\"><a href=\"#cb1-7\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/user/5/user_test.go\">Listing\n<code>user/5</code></a>)</p>\n<p>At first glance, this is plausible. We create a test user, Alice, and\ncheck if she subsequently exists. If not, the test fails. That part is\nfine. So, can you see what’s missing? If not, you might like to take a\nminute to think about it before reading on.</p>\n<p>It’s always worth asking of any test whether it rigorously checks its\n<em>preconditions</em> as well as its postconditions. The developer’s\nfocus, naturally enough, tends to be on the state of the world\n<em>after</em> the operation under test, but that can result in some\nrisky assumptions about its <em>prior</em> state.</p>\n<p>Suppose <code>Create</code> actually does nothing. How could this\ntest pass? Only when Alice already exists. And would we know if that was\nthe case?</p>\n<p>Our test checks that Alice exists <em>after</em> calling\n<code>Create</code>, but what’s missing is a check that she doesn’t\nexist <em>beforehand</em>.</p>\n<p>In other words, suppose we don’t clean up the database after each\ntest run, so if Alice was <em>ever</em> created, she’ll still be there.\nAnd suppose someone later introduces a bug into <code>Create</code> that\nprevents it from actually creating users.</p>\n<p>To put it another way, here’s an obviously incorrect implementation\nthat nevertheless passes this test:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb2-1\"><a href=\"#cb2-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">type</span> User <span class=\"kw\">struct</span> <span class=\"op\">{</span></span>\n<span id=\"cb2-2\"><a href=\"#cb2-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    Name <span class=\"dt\">string</span></span>\n<span id=\"cb2-3\"><a href=\"#cb2-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb2-4\"><a href=\"#cb2-4\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb2-5\"><a href=\"#cb2-5\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">var</span> <span class=\"op\">(</span></span>\n<span id=\"cb2-6\"><a href=\"#cb2-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    m     <span class=\"op\">=</span> <span class=\"bu\">new</span><span class=\"op\">(</span>sync<span class=\"op\">.</span>Mutex<span class=\"op\">)</span></span>\n<span id=\"cb2-7\"><a href=\"#cb2-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    users <span class=\"op\">=</span> <span class=\"kw\">map</span><span class=\"op\">[</span><span class=\"dt\">string</span><span class=\"op\">]*</span>User<span class=\"op\">{</span></span>\n<span id=\"cb2-8\"><a href=\"#cb2-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>        <span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">:</span> <span class=\"op\">{</span></span>\n<span id=\"cb2-9\"><a href=\"#cb2-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>            Name<span class=\"op\">:</span> <span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">,</span></span>\n<span id=\"cb2-10\"><a href=\"#cb2-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>        <span class=\"op\">},</span></span>\n<span id=\"cb2-11\"><a href=\"#cb2-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb2-12\"><a href=\"#cb2-12\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">)</span></span>\n<span id=\"cb2-13\"><a href=\"#cb2-13\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb2-14\"><a href=\"#cb2-14\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Create<span class=\"op\">(</span>name <span class=\"dt\">string</span><span class=\"op\">)</span> <span class=\"op\">{}</span></span>\n<span id=\"cb2-15\"><a href=\"#cb2-15\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb2-16\"><a href=\"#cb2-16\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Exists<span class=\"op\">(</span>name <span class=\"dt\">string</span><span class=\"op\">)</span> <span class=\"dt\">bool</span> <span class=\"op\">{</span></span>\n<span id=\"cb2-17\"><a href=\"#cb2-17\" aria-hidden=\"true\" tabindex=\"-1\"></a>    m<span class=\"op\">.</span>Lock<span class=\"op\">()</span></span>\n<span id=\"cb2-18\"><a href=\"#cb2-18\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">defer</span> m<span class=\"op\">.</span>Unlock<span class=\"op\">()</span></span>\n<span id=\"cb2-19\"><a href=\"#cb2-19\" aria-hidden=\"true\" tabindex=\"-1\"></a>    _<span class=\"op\">,</span> ok <span class=\"op\">:=</span> users<span class=\"op\">[</span>name<span class=\"op\">]</span></span>\n<span id=\"cb2-20\"><a href=\"#cb2-20\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> ok</span>\n<span id=\"cb2-21\"><a href=\"#cb2-21\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/user/5/user.go\">Listing\n<code>user/5</code></a>)</p>\n<p>We thought we were testing <code>Create</code>, but we really aren’t,\nbecause <code>Create</code> does nothing at all, yet the test doesn’t\ndetect that. Alice <em>always</em> exists, so the test always passes.\nThis kind of <em>mirage test</em> is especially dangerous, because it\nlooks like you have a test, but you don’t.</p>\n<p>It turns out that <code>Create</code> needs not just to leave the\nworld in a state where Alice exists. What’s important about\n<code>Create</code> is that it <em>changes</em> the world from a state\nwhere Alice doesn’t exist to one where she does.</p>\n<p>You might think that goes without saying, but we’ve just proved that\nit doesn’t. We need to pay attention to preconditions as well as\npostconditions, according to the contract that the system under test is\nsupposed to fulfil.</p>\n<p>Let’s write a test that <em>would</em> catch this bug, then:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb3-1\"><a href=\"#cb3-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestCreateCreatesGivenUser<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb3-2\"><a href=\"#cb3-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb3-3\"><a href=\"#cb3-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb3-4\"><a href=\"#cb3-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Fatal<span class=\"op\">(</span><span class=\"st\">&quot;Alice unexpectedly exists&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb3-5\"><a href=\"#cb3-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb3-6\"><a href=\"#cb3-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Create<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb3-7\"><a href=\"#cb3-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb3-8\"><a href=\"#cb3-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Alice not created&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb3-9\"><a href=\"#cb3-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb3-10\"><a href=\"#cb3-10\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/user/6/user_test.go\">Listing\n<code>user/6</code></a>)</p>\n<p>The difference is very simple, but important: we check our\npreconditions.</p>\n<p>What about <em>this</em> test, then?</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb4-1\"><a href=\"#cb4-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestDeleteDeletesGivenUser<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb4-2\"><a href=\"#cb4-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb4-3\"><a href=\"#cb4-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Create<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb4-4\"><a href=\"#cb4-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Delete<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb4-5\"><a href=\"#cb4-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb4-6\"><a href=\"#cb4-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Alice still exists after delete&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb4-7\"><a href=\"#cb4-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb4-8\"><a href=\"#cb4-8\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>Again, this looks reasonable on a cursory inspection. It creates\nAlice, deletes her (sorry, Alice), and then ensures that she no longer\nexists. What could be wrong with <code>Delete</code> that this test\nwouldn’t catch?</p>\n<p>Well, what if <em>both</em> <code>Create</code> and\n<code>Delete</code> do nothing at all? That seems like a pretty major\nbug, yet this test doesn’t detect it. There are no preconditions, so the\noutcome of the test is the same whether <code>Create</code> and\n<code>Delete</code> actually have any effect or not. The test isn’t\nwrong, as far as it goes: it just doesn’t <em>go</em> far enough.\nThere’s a pretty big loophole in it.</p>\n<p>This kind of bug isn’t as unlikely as you might think, either. I’ve\nmade this exact mistake in the past: I stubbed out <code>Create</code>\nand <code>Delete</code> methods with placeholders, then forgot that I\nhadn’t finished them, because the test was passing. It’s easy to do.</p>\n<p>What we’re missing here, in fact, is another precondition: that the\nuser <em>does</em> exist before we try to delete them.</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb5-1\"><a href=\"#cb5-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestDeleteDeletesGivenUser<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb5-2\"><a href=\"#cb5-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb5-3\"><a href=\"#cb5-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Create<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb5-4\"><a href=\"#cb5-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb5-5\"><a href=\"#cb5-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Alice not created&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb5-6\"><a href=\"#cb5-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb5-7\"><a href=\"#cb5-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Delete<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb5-8\"><a href=\"#cb5-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb5-9\"><a href=\"#cb5-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Alice still exists after delete&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb5-10\"><a href=\"#cb5-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb5-11\"><a href=\"#cb5-11\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/user/6/user_test.go\">Listing\n<code>user/6</code></a>)</p>\n<p>If <code>Create</code> doesn’t do anything, this test will fail at\nthe first check. If <code>Delete</code> doesn’t do anything, it’ll fail\nat the second.</p>\n<p>In any non-trivial codebase, you’re pretty much guaranteed to find at\nleast a few tests that are optimistically feeble in this way. Look for\nany test that doesn’t properly establish its preconditions, and fix it.\nThis will add a lot of value to the test suite overall.</p>\n<p>Another example of this kind of problem is when the test fails to\ncheck some important but implicit <em>postconditions</em>. For example,\nin <code>TestDelete</code>, the explicit postcondition here is that\nAlice shouldn’t exist after deletion, so what are we implicitly missing?\nWhat else could a reasonable person ask for from a <code>Delete</code>\nfunction?</p>\n<p>As usual, a productive way to answer that is to think about possible\nbugs in <code>Delete</code>. Suppose, for example, that\n<code>Delete</code> mistakenly deletes not only Alice, but <em>all</em>\nusers in the database. That kind of thing is surprisingly easy to do,\nespecially with SQL queries (omitting a <code>WHERE</code> clause, for\nexample).</p>\n<p>If calling <code>Delete</code> on a single user instead nukes the\nwhole database, that’s a pretty major bug, wouldn’t you say? This test\ndoesn’t detect it, because it focuses only on what <em>should</em>\nhappen, and ignores what shouldn’t.</p>\n<p>How <em>could</em> we detect such a bug, then? Quite easily, it turns\nout.</p>\n<p>Here’s what we do. We create <em>two</em> users in the test, but\ndelete only one of them. Then we check that the one we deleted doesn’t\nexist, and the one we didn’t delete still exists:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb6-1\"><a href=\"#cb6-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestDeleteDeletesGivenUserOnly<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb6-2\"><a href=\"#cb6-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb6-3\"><a href=\"#cb6-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Create<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb6-4\"><a href=\"#cb6-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb6-5\"><a href=\"#cb6-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Alice not created&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb6-6\"><a href=\"#cb6-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb6-7\"><a href=\"#cb6-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Create<span class=\"op\">(</span><span class=\"st\">&quot;Bob&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb6-8\"><a href=\"#cb6-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Bob&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb6-9\"><a href=\"#cb6-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Bob not created&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb6-10\"><a href=\"#cb6-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb6-11\"><a href=\"#cb6-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Delete<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb6-12\"><a href=\"#cb6-12\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb6-13\"><a href=\"#cb6-13\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Alice still exists after delete&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb6-14\"><a href=\"#cb6-14\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb6-15\"><a href=\"#cb6-15\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Bob&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb6-16\"><a href=\"#cb6-16\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Bob was unexpectedly deleted&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb6-17\"><a href=\"#cb6-17\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb6-18\"><a href=\"#cb6-18\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>This test has accumulated a bit of paperwork, so let’s refactor that\nout into a helper function:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb7-1\"><a href=\"#cb7-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestDeleteDeletesGivenUserOnly<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb7-2\"><a href=\"#cb7-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb7-3\"><a href=\"#cb7-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    createUserOrFail<span class=\"op\">(</span>t<span class=\"op\">,</span> <span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb7-4\"><a href=\"#cb7-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    createUserOrFail<span class=\"op\">(</span>t<span class=\"op\">,</span> <span class=\"st\">&quot;Bob&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb7-5\"><a href=\"#cb7-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Delete<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb7-6\"><a href=\"#cb7-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Alice&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb7-7\"><a href=\"#cb7-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Alice still exists after delete&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb7-8\"><a href=\"#cb7-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb7-9\"><a href=\"#cb7-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>user<span class=\"op\">.</span>Exists<span class=\"op\">(</span><span class=\"st\">&quot;Bob&quot;</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb7-10\"><a href=\"#cb7-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;Bob was unexpectedly deleted&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb7-11\"><a href=\"#cb7-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb7-12\"><a href=\"#cb7-12\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span>\n<span id=\"cb7-13\"><a href=\"#cb7-13\" aria-hidden=\"true\" tabindex=\"-1\"></a></span>\n<span id=\"cb7-14\"><a href=\"#cb7-14\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> createUserOrFail<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">,</span> name <span class=\"dt\">string</span><span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb7-15\"><a href=\"#cb7-15\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Helper<span class=\"op\">()</span></span>\n<span id=\"cb7-16\"><a href=\"#cb7-16\" aria-hidden=\"true\" tabindex=\"-1\"></a>    user<span class=\"op\">.</span>Create<span class=\"op\">(</span>name<span class=\"op\">)</span></span>\n<span id=\"cb7-17\"><a href=\"#cb7-17\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> <span class=\"op\">!</span>user<span class=\"op\">.</span>Exists<span class=\"op\">(</span>name<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb7-18\"><a href=\"#cb7-18\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Errorf<span class=\"op\">(</span><span class=\"st\">&quot;%s not created&quot;</span><span class=\"op\">,</span> name<span class=\"op\">)</span></span>\n<span id=\"cb7-19\"><a href=\"#cb7-19\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb7-20\"><a href=\"#cb7-20\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/user/7/user_test.go\">Listing\n<code>user/7</code></a>)</p>\n<p>Who would have thought that there were so much scope for things to go\nwrong with a seemingly simple <code>Delete</code> function? Well,\n<em>you</em> would, or at least you will now.</p>\n<p>If you find yourself, as a result, becoming thoroughly sceptical\nabout the idea that <em>anything</em> works the way it’s supposed to,\ncongratulations: you’re thinking like a tester.</p>\n<h2 id=\"persnickety-tests\">Persnickety tests</h2>\n<p>Sometimes, though not often, people can take testing a bit\n<em>too</em> much to heart, and test more than strictly necessary. As\nwe’ve seen, it’s much easier to err the other way, and leave out\nimportant things such as preconditions and implicit postconditions, like\nnot deleting all the users in the database. But overtesting does afflict\nsome test suites.</p>\n<p>It’s important to keep tests focused on only the part of the system\nthey’re supposed to care about, and on only the <em>behaviour</em> that\nmatters. They should avoid checking for irrelevant things.</p>\n<p>Beware also of simply comparing too much. Sometimes it can be\nconvenient to compare a function’s <em>entire</em> result against an\nexpected value, rather than individually checking each of its fields,\nbut it’s not always a good idea.</p>\n<p>Comparing the whole struct makes sense when all the fields are\naffected by the behaviour under test. But when only some fields are\nimportant to <em>this</em> test, checking irrelevant fields makes the\ntest brittle, and obscures its real purpose. The same applies to\nchecking entire strings or output files, when only certain parts of the\ndata are actually important.</p>\n<blockquote>\n<p><em>The easiest way to avoid brittle tests is to check only the\nproperties you care about. Be selective in your assertions. Don’t check\nfor exact string matches, for example, but look for relevant substrings\nthat will remain unchanged as the program evolves.</em><br />\n—Alan Donovan &amp; Brian Kernighan, <a href=\"https://amzn.to/3ObBI2O\">“The Go Programming Language”</a></p>\n</blockquote>\n<p>Watch out for tests that lazily compare output against a golden file,\nfor example, when the behaviour they’re testing is only about a small\nsubset of that file. Similarly, <a href=\"https://bitfieldconsulting.com/posts/comparing-errors\">a test\nshould not assert the exact value of an error</a>, but only that there\n<em>is</em> some error, when there’s supposed to be.</p>\n<p>Some exposure to the idea of <em>property-based</em> testing, as\ncommonly used in <a href=\"https://bitfieldconsulting.com/posts/fuzz-tests\">fuzz testing</a>, can also\nbe helpful for constructing robust tests. For example, what’s important\nabout a result is often not its <em>exact</em> value, but some\n<em>property</em> of the value, especially an invariant property.</p>\n<p>I recently reviewed a program that needed to create a “fingerprint”\nof a piece of data, for deduplication purposes. In case the same data\nwas submitted to the system later, the fingerprint would enable the\nsystem to recognise it without actually having to store all the data,\nwhich could be very large.</p>\n<p>A cryptographic digest, or hash value, is an obvious way to do this,\nso the program had a test something like this:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb8-1\"><a href=\"#cb8-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestHashReturnsMD5HashOfGivenData<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb8-2\"><a href=\"#cb8-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb8-3\"><a href=\"#cb8-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    data <span class=\"op\">:=</span> <span class=\"op\">[]</span><span class=\"dt\">byte</span><span class=\"op\">(</span><span class=\"st\">&quot;These pretzels are making me thirsty.&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb8-4\"><a href=\"#cb8-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    want <span class=\"op\">:=</span> md5<span class=\"op\">.</span>Sum<span class=\"op\">(</span>data<span class=\"op\">)</span></span>\n<span id=\"cb8-5\"><a href=\"#cb8-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    got <span class=\"op\">:=</span> fingerprint<span class=\"op\">.</span>Hash<span class=\"op\">(</span>data<span class=\"op\">)</span></span>\n<span id=\"cb8-6\"><a href=\"#cb8-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> want <span class=\"op\">!=</span> got <span class=\"op\">{</span></span>\n<span id=\"cb8-7\"><a href=\"#cb8-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Errorf<span class=\"op\">(</span><span class=\"st\">&quot;want %v, got %v&quot;</span><span class=\"op\">,</span> want<span class=\"op\">,</span> got<span class=\"op\">)</span></span>\n<span id=\"cb8-8\"><a href=\"#cb8-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb8-9\"><a href=\"#cb8-9\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/fingerprint/1/fingerprint_test.go\">Listing\n<code>fingerprint/1</code></a>)</p>\n<p>The implementation of <code>Hash</code> doesn’t matter, but let’s\nassume it’s something like this:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb9-1\"><a href=\"#cb9-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Hash<span class=\"op\">(</span>data <span class=\"op\">[]</span><span class=\"dt\">byte</span><span class=\"op\">)</span> <span class=\"op\">[</span>md5<span class=\"op\">.</span>Size<span class=\"op\">]</span><span class=\"dt\">byte</span> <span class=\"op\">{</span></span>\n<span id=\"cb9-2\"><a href=\"#cb9-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> md5<span class=\"op\">.</span>Sum<span class=\"op\">(</span>data<span class=\"op\">)</span></span>\n<span id=\"cb9-3\"><a href=\"#cb9-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/fingerprint/1/fingerprint.go\">Listing\n<code>fingerprint/1</code></a>)</p>\n<p>Fine. But <a href=\"https://en.wikipedia.org/wiki/MD5#Security\">MD5 is\ninsecure</a>, so I suggested using a SHA-256 hash instead:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb10-1\"><a href=\"#cb10-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> Hash<span class=\"op\">(</span>data <span class=\"op\">[]</span><span class=\"dt\">byte</span><span class=\"op\">)</span> <span class=\"op\">[</span>sha256<span class=\"op\">.</span>Size<span class=\"op\">]</span><span class=\"dt\">byte</span> <span class=\"op\">{</span></span>\n<span id=\"cb10-2\"><a href=\"#cb10-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">return</span> sha256<span class=\"op\">.</span>Sum256<span class=\"op\">(</span>data<span class=\"op\">)</span></span>\n<span id=\"cb10-3\"><a href=\"#cb10-3\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/fingerprint/2/fingerprint.go\">Listing\n<code>fingerprint/2</code></a>)</p>\n<p>This broke the test, which makes no sense, because <code>Hash</code>\n<em>works</em>. So what’s the problem?</p>\n<p>Well, what are we really testing here? Not that <code>Hash</code>\nproduces an <em>MD5</em> hash, specifically; that’s incidental. What\nmatters is that the same data should always hash to the same value,\nwhatever that value actually is. And, no less importantly, that\n<em>different</em> data should hash to different values.</p>\n<p>So we ended up with a test something like this instead:</p>\n<pre class=\"sourceCode go\"><code class=\"sourceCode go\"><span id=\"cb11-1\"><a href=\"#cb11-1\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"kw\">func</span> TestHashGivesSameUniqueHashForSameData<span class=\"op\">(</span>t <span class=\"op\">*</span>testing<span class=\"op\">.</span>T<span class=\"op\">)</span> <span class=\"op\">{</span></span>\n<span id=\"cb11-2\"><a href=\"#cb11-2\" aria-hidden=\"true\" tabindex=\"-1\"></a>    t<span class=\"op\">.</span>Parallel<span class=\"op\">()</span></span>\n<span id=\"cb11-3\"><a href=\"#cb11-3\" aria-hidden=\"true\" tabindex=\"-1\"></a>    data <span class=\"op\">:=</span> <span class=\"op\">[]</span><span class=\"dt\">byte</span><span class=\"op\">(</span><span class=\"st\">&quot;These pretzels are making me thirsty.&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb11-4\"><a href=\"#cb11-4\" aria-hidden=\"true\" tabindex=\"-1\"></a>    orig <span class=\"op\">:=</span> fingerprint<span class=\"op\">.</span>Hash<span class=\"op\">(</span>data<span class=\"op\">)</span></span>\n<span id=\"cb11-5\"><a href=\"#cb11-5\" aria-hidden=\"true\" tabindex=\"-1\"></a>    same <span class=\"op\">:=</span> fingerprint<span class=\"op\">.</span>Hash<span class=\"op\">(</span>data<span class=\"op\">)</span></span>\n<span id=\"cb11-6\"><a href=\"#cb11-6\" aria-hidden=\"true\" tabindex=\"-1\"></a>    different <span class=\"op\">:=</span> fingerprint<span class=\"op\">.</span>Hash<span class=\"op\">([]</span><span class=\"dt\">byte</span><span class=\"op\">(</span><span class=\"st\">&quot;Hello, Newman&quot;</span><span class=\"op\">))</span></span>\n<span id=\"cb11-7\"><a href=\"#cb11-7\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> orig <span class=\"op\">!=</span> same <span class=\"op\">{</span></span>\n<span id=\"cb11-8\"><a href=\"#cb11-8\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;same data produced different hash&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb11-9\"><a href=\"#cb11-9\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb11-10\"><a href=\"#cb11-10\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"cf\">if</span> orig <span class=\"op\">==</span> different <span class=\"op\">{</span></span>\n<span id=\"cb11-11\"><a href=\"#cb11-11\" aria-hidden=\"true\" tabindex=\"-1\"></a>        t<span class=\"op\">.</span>Error<span class=\"op\">(</span><span class=\"st\">&quot;different data produced same hash&quot;</span><span class=\"op\">)</span></span>\n<span id=\"cb11-12\"><a href=\"#cb11-12\" aria-hidden=\"true\" tabindex=\"-1\"></a>    <span class=\"op\">}</span></span>\n<span id=\"cb11-13\"><a href=\"#cb11-13\" aria-hidden=\"true\" tabindex=\"-1\"></a><span class=\"op\">}</span></span></code></pre>\n<p>(<a href=\"https://github.com/bitfield/tpg-tests/blob/main/fingerprint/2/fingerprint_test.go\">Listing\n<code>fingerprint/2</code></a>)</p>\n<p>This test is better, because it doesn’t care about the implementation\ndetails of <code>Hash</code>, such as which algorithm is used. What it\ncares about is that the same input to <code>Hash</code> always gives the\nsame result, so it catches bugs like an unstable hash algorithm or even\na random result.</p>\n<p>And, because a maliciously lazy implementation of <code>Hash</code>\nmight simply <em>always</em> return the same fixed value, the test also\nrequires that different data hashes to different values.</p>\n<p>This isn’t completely bug-proof, of course. It’s possible, for\nexample, that <code>Hash</code> always produces the same value unless\nthe input is exactly “Hello, Newman”. We could use fuzz testing to\ntackle this, or just a table test with a bunch of different inputs.</p>\n<p>But you get the point. We made the test both less brittle and less\nfeeble without adding much extra code; all it took was a little extra\n<em>thinking</em>.</p>\n<p>In the next and final post in this series, we’ll look at speed and\nreliability of tests. If the test suite as a whole is too slow, it\nsimply won’t be run, so it’s no use. On the other hand, if the tests are\nunreliable, and often fail even when the code is correct, they’re also\nuseless in a different way. Let’s talk about how to fix that situation\nnext time.</p>","flags":null,"enclosureUrl":"","enclosureMime":""}]}