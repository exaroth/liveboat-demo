{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","items":[{"title":"Implementing background jobs","url":"https://www.reddit.com/r/golang/comments/1headif/implementing_background_jobs/","date":1734204466,"author":"/u/jessesv_","unread":true,"desc":"","content":"<!-- SC_OFF --><div class=\"md\"><p>I have a desktop app using Wails where I want to be able to run long running tasks in the background.</p> <p>Coming from .net, I&#39;ve been looking for packages that are similar to hangfire where i can just do the following</p> <p><code>c# BackgroundJob.Enqueue&lt;IBackgroundJob&gt;(job =&gt; job.Execute()); </code></p> <p>I&#39;ve found a few packages and an implementation using goroutines but not sure how to decide which one to go for.</p> <p><strong>github.com/hibiken/asynq</strong>: It seems the way to enqueue tasks here is to have a payload, task, and task handler, where different tasks are handled by their own handlers based on a list of task types. Does this mean I can have just one task handler and have it handle all tasks?</p> <p><strong>github.com/gammazero/workerpool</strong>: This one seems more straight forward where you just create a new workerpool and can submit functions that perform some work. Makes a lot more sense in my head but maybe I can do the same in asynq?</p> <p><strong>goroutines</strong>: I found a post on stackoverflow where the same was being done with a simple goroutine but the issue was that any further requests would hang until the goroutine completed, it looked like this: </p> <p><code>go func MyHandler(w http.ResponseWriter, r *http.Request) { //handle form values go doSomeBackgroundWork() // this will take 2 or 3 seconds w.WriteHeader(http.StatusOK) } </code></p> <p>Ideally what I would like to have is a backgroundJobService of some sorts where I call an enqueue method and pass the struct that implements something like IBackgroundJob with an Execute method.</p> <p>What would best fit my usecase here?</p> <p>Thanks</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/jessesv_\"> /u/jessesv_ </a> <br/> <span><a href=\"https://www.reddit.com/r/golang/comments/1headif/implementing_background_jobs/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/golang/comments/1headif/implementing_background_jobs/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"How easily can Go exe be decompiled/reversed compared to other languages ?","url":"https://www.reddit.com/r/golang/comments/1hef3xg/how_easily_can_go_exe_be_decompiledreversed/","date":1734217755,"author":"/u/D4kzy","unread":true,"desc":"","content":"<!-- SC_OFF --><div class=\"md\"><p>I noticed that when I compile my binaries for windows with GO, some of the path and package name are in the binary itself.</p> <p>When I use -trimpath flag it gets better, but still there is some stuff.</p> <p>It made me think how easy it is to reverse GO exe ? How to make it more time consuming for bad people ?</p> <p>I know everything can be reversed with enough time. I know Java and python (pyinstaller) default exe can be literally decompiled to get a good portion of the source code. I wonder the case with Go ...</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/D4kzy\"> /u/D4kzy </a> <br/> <span><a href=\"https://www.reddit.com/r/golang/comments/1hef3xg/how_easily_can_go_exe_be_decompiledreversed/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/golang/comments/1hef3xg/how_easily_can_go_exe_be_decompiledreversed/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Modifying slice argument","url":"https://www.reddit.com/r/golang/comments/1heirl0/modifying_slice_argument/","date":1734229320,"author":"/u/fleekonpoint","unread":true,"desc":"","content":"<!-- SC_OFF --><div class=\"md\"><p>If I have a slice as an argument to a function and I want to modify the slice (so that the changes to the slice will be available after the function call ends), are there just 2 ways to accomplish this?</p> <ol> <li>Return a new slice from the function</li> <li>Pass a pointer to the slice and modify the slice via the pointer</li> </ol> <p>``` func main() { s := make([]int, 0)</p> <pre><code>// ModifyPointer(&amp;s) // or // s = ModifyReturn(s) // should return 1,2,3,4,5 fmt.Println(s) </code></pre> <p>}</p> <p>func ModifyPointer(s <em>[]int) { for i := range 5 { *s = append(</em>s, 1) } }</p> <p>func ModifyReturn(s []int) []int { for i := range 5 { s = append(s, 1) } </p> <pre><code>return s </code></pre> <p>} ```</p> <p>Are these correct? And is one preferred over the other? </p> <p>EDIT: Also, if I don&#39;t have to grow or shrink the slice, I don&#39;t need either option right? Since the underlying memory address for the slice data won&#39;t change?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/fleekonpoint\"> /u/fleekonpoint </a> <br/> <span><a href=\"https://www.reddit.com/r/golang/comments/1heirl0/modifying_slice_argument/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/golang/comments/1heirl0/modifying_slice_argument/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Key Value store alternative to Redis for Golang","url":"https://www.reddit.com/r/golang/comments/1hepxjo/key_value_store_alternative_to_redis_for_golang/","date":1734258625,"author":"/u/Efficient-Pea-2990","unread":true,"desc":"","content":"<!-- SC_OFF --><div class=\"md\"><p>We have a REST API Server written in Golang. We are currently using Redis for serving Access and Refresh token keys. We only store keys(ids) and values. We heard about Bitcask, Badger, BoltDB etc. It will be much helpful, if any one can share their experience on using Go based KeyValue store/database.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Efficient-Pea-2990\"> /u/Efficient-Pea-2990 </a> <br/> <span><a href=\"https://www.reddit.com/r/golang/comments/1hepxjo/key_value_store_alternative_to_redis_for_golang/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/golang/comments/1hepxjo/key_value_store_alternative_to_redis_for_golang/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Announcing the GoDev Non-Stop 30 Challenge! üöÄ","url":"https://www.reddit.com/r/golang/comments/1hes0f7/announcing_the_godev_nonstop_30_challenge/","date":1734267288,"author":"/u/Much-Escape3554","unread":true,"desc":"","content":"<!-- SC_OFF --><div class=\"md\"><p>What is it?</p> <p>For 30 days straight‚ÄîJanuary 1 to January 31, 2025‚ÄîI‚Äôll be solving your toughest Go development tasks for free! From distributed systems to Kafka pipelines, MongoDB integrations, ClickHouse analytics, and gRPC APIs‚ÄîI‚Äôm here to code, deliver, and inspire.</p> <p>How to Participate?</p> <pre><code>Submit your Go coding challenges before December 31, 2024, 23:59. Challenges should focus on real-world high-load tasks, performance bottlenecks, or interesting problem spaces. Every solution will be open source, cleanly implemented, documented, and tested. You get working code and fresh insights. </code></pre> <p>Examples of Tasks:</p> <pre><code>Build a distributed task scheduler with Kafka and MongoDB. Implement budget and frequency limiters for RTB systems. Develop real-time monitoring tools with Prometheus and Grafana. </code></pre> <p>‚öôÔ∏è What‚Äôs in it for you?</p> <pre><code>A robust, production-quality solution for your problem. A chance to collaborate on exciting open-source projects. Recognition and visibility in the Go developer community. </code></pre> <p>Limited Slots! If there aren‚Äôt enough tasks, I‚Äôll generate synthetic ones with ChatGPT. If submissions exceed my capacity, I‚Äôll pick the most intriguing challenges. </p> <p>Drop your ideas as GitHub issues here: <a href=\"https://github.com/devflex-pro/01-2025-Challenge\">[GitHub]</a></p> <p>Let‚Äôs build, share, and inspire‚ÄîNon-Stop 30 starts soon! </p> <p>Spread the word, tag your friends, and submit your tasks!</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Much-Escape3554\"> /u/Much-Escape3554 </a> <br/> <span><a href=\"https://www.reddit.com/r/golang/comments/1hes0f7/announcing_the_godev_nonstop_30_challenge/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/golang/comments/1hes0f7/announcing_the_godev_nonstop_30_challenge/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"What are your biggest learnings about Go and how did you get to them?","url":"https://www.reddit.com/r/golang/comments/1heuhyq/what_are_your_biggest_learnings_about_go_and_how/","date":1734275427,"author":"/u/TheRealHackfred","unread":true,"desc":"","content":"<!-- SC_OFF --><div class=\"md\"><p>I have been using Go for 3 years now and I think it&#39;s a great language. After using a language for a while to me it‚Äôs interesting to evaluate key learnings that changed the way I write code - either in that language specifically or in general. </p> <p>So I am curious: What were your key learnings and how did you come to internalise them?</p> <p>I have two of my own to start with:</p> <p>1 Don‚Äôt pass parameters (mostly structs) as pointers for optimisation.</p> <p>At the beginning we were cautious of passing larger structs (&gt;= 1KB) by value so regularly we used pointers instead. CPUs are quite efficient though and it turns out you need to pass such a struct many times (&gt;1000) before you can notice any real difference. These days we only pass structs as pointers if they‚Äôre nullable or (in rare cases) mutable. I can just recommend to run a simple benchmark on your own if you are interested in that topic (nice side-effect: you learn about Go‚Äôs benchmarking tools).</p> <p>2 Goroutines are much cheaper than OS threads</p> <p>Coming from Java and Scala I had already experienced that context switching can be costly and limit throughput in some applications (e.g. a web server that creates one thread per incoming request). So I was amazed to see how cheap Goroutines are in comparison (again by running and comparing two simple applications) which just took away the reluctance to create a high number of go routines. </p> <p>I love these kinds of insights so I would be thankful if you can share some of yours.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/TheRealHackfred\"> /u/TheRealHackfred </a> <br/> <span><a href=\"https://www.reddit.com/r/golang/comments/1heuhyq/what_are_your_biggest_learnings_about_go_and_how/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/golang/comments/1heuhyq/what_are_your_biggest_learnings_about_go_and_how/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""}]}