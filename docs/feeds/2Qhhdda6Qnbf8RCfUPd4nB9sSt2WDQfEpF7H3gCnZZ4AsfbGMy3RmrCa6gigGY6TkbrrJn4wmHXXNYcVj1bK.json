{
  "id": "2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK",
  "title": "top scoring links : rust",
  "displayTitle": "Reddit - Rust",
  "url": "https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6",
  "feedLink": "https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6",
  "items": [
    {
      "title": "Why is u32/i32 faster than u8?",
      "url": "https://www.reddit.com/r/rust/comments/1h7wqx6/why_is_u32i32_faster_than_u8/",
      "date": 1733473272,
      "author": "/u/ClimberSeb",
      "unread": true,
      "desc": "",
      "content": "<!-- SC_OFF --><div class=\"md\"><p>I solved day 5&#39;s advent of code problem with a rust program.</p> <p>There I mainly used <span class=\"md-spoiler-text\">Vec::sort_by, a HashSet::&lt;(i32, i32)&gt; plus some recursive depth first search</span> to solve it.</p> <p>At first I didn&#39;t bother checking how big/small the numbers is in my input so I just used an i32 to store them.</p> <p>After getting the right answer I was curious to see how much faster the code would be with the &quot;right&quot; datatype so I changed the numbers to u8. Then the code ran ~50% slower! I tried with i8, i16, u16 all with about the same performance as using u8. Changing to u32 didn&#39;t make a difference compared to i32, and using u64/i64 made it 73% slower.</p> <p>I don&#39;t know the x86_64 instructions, but I&#39;ve assumed the cost of widening the types would be free on a superscalar architecture even if it needed special instructions to do so. What else could cause the slowdown? Worse hashing performance?</p> <p>---- Edit after comments:</p> <p>The code is here: <a href=\"https://pastebin.com/y0xVWHfs\">https://pastebin.com/y0xVWHfs</a></p> <p>It uses these crates:<br/> aoc-runner = &quot;0.3.0&quot;<br/> aoc-runner-derive = &quot;0.3.0&quot;</p> <p>but one could just include the input file and add a main that calls input_generator with it, followed by calling solve_part2 with the result from input_generator.</p> <p>I&#39;ve benchmarked it with cargo-aoc bench, it compiles the code in release mode when benchmarking. It only benchmarks the solve_part2 function, not the input_generator call.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/ClimberSeb\"> /u/ClimberSeb </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1h7wqx6/why_is_u32i32_faster_than_u8/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1h7wqx6/why_is_u32i32_faster_than_u8/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Announcing self_cell version 1.1.0",
      "url": "https://www.reddit.com/r/rust/comments/1h7xpy9/announcing_self_cell_version_110/",
      "date": 1733477715,
      "author": "/u/Voultapher",
      "unread": true,
      "desc": "",
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Recently I released a new minor version of <a href=\"https://github.com/Voultapher/self_cell\">self_cell</a> that adds a <a href=\"https://github.com/Voultapher/self_cell/pull/36\">long</a> requested feature: mutable references to the owner. In the past I was reluctant to add this feature because the core of the library is exceedingly tricky to get right, and I had to yank versions off of crates.io half a dozen times over the years - something every other serious self referential crate had to do as well, getting them right, especially variance, is extremely difficult - and even had a <a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0070.html\">RUSTSEC advisory</a>. So given my design goal of keeping the crate minimal and avoiding unnecessary changes to the existing <code>unsafe</code> code, I had given up on adding this feature, but earlier this year someone raised the topic again and I had an idea for how to add this functionality without having to change the existing code. In essence I unknowingly re-derived the <a href=\"https://doc.rust-lang.org/std/cell/struct.RefMut.html#method.leak\"><code>RefCell::leak</code></a> API. Users can now wrap the owner in the crate provided type <a href=\"https://docs.rs/self_cell/1.1.0/self_cell/struct.MutBorrow.html\"><code>MutBorrow</code></a> which allows a <code>(&amp;self) -&gt; &amp;mut T </code> transition, <em>but only once</em>. This way the existing APIs, documentation and code all stay the same but the wrapper type adds support for common use-cases such as <code>ZipArchive</code> etc.</p> <p>This brings self_cell closer to feature parity with <a href=\"https://github.com/someguynamedjosh/ouroboros\">ouroboros</a>. If you are happy with ouroboros there is no need to switch, it has also been reviewed extensively and has capabilities self_cell lacks. The renewed issue was raised by one of the rusqlite maintainers who wants to migrate to it because self_cell generates less code and is faster to compile, so if you&#39;re usage of ouroboros is feature compatible with self_cell and you care about compile times and or binary-size this might be avenue for improvement in your project.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Voultapher\"> /u/Voultapher </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1h7xpy9/announcing_self_cell_version_110/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1h7xpy9/announcing_self_cell_version_110/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Rustc Trait System Refactor Initiative Update: Stabilizing `-Znext-solver=coherence` | Inside Rust Blog",
      "url": "https://www.reddit.com/r/rust/comments/1h7y9jp/rustc_trait_system_refactor_initiative_update/",
      "date": 1733480161,
      "author": "/u/slanterns",
      "unread": true,
      "desc": "",
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/slanterns\"> /u/slanterns </a> <br/> <span><a href=\"https://blog.rust-lang.org/inside-rust/2024/12/04/trait-system-refactor-initiative.html\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1h7y9jp/rustc_trait_system_refactor_initiative_update/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Announcing ProSA: Our New Rust Open Source Library for Handling Transactional Flow at Worldline Fintech",
      "url": "https://www.reddit.com/r/rust/comments/1h80eiq/announcing_prosa_our_new_rust_open_source_library/",
      "date": 1733488653,
      "author": "/u/reneca",
      "unread": true,
      "desc": "",
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/reneca\"> /u/reneca </a> <br/> <span><a href=\"https://blog.worldline.tech/2024/11/26/prosa.html\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1h80eiq/announcing_prosa_our_new_rust_open_source_library/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "[Media] Actuate UI: Now with Material design components, better ergonomics with Bevy, and a faster runtime with support for pause/resume",
      "url": "https://www.reddit.com/r/rust/comments/1h87jod/media_actuate_ui_now_with_material_design/",
      "date": 1733508262,
      "author": "/u/matthunz",
      "unread": true,
      "desc": "",
      "content": "&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/matthunz\"> /u/matthunz </a> <br/> <span><a href=\"https://i.redd.it/4o7pdfp2q95e1.jpeg\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1h87jod/media_actuate_ui_now_with_material_design/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    },
    {
      "title": "Why can deriving Copy pessimize performance by 60%?",
      "url": "https://www.reddit.com/r/rust/comments/1h8dj64/why_can_deriving_copy_pessimize_performance_by_60/",
      "date": 1733523917,
      "author": "/u/jogru0",
      "unread": true,
      "desc": "",
      "content": "<!-- SC_OFF --><div class=\"md\"><p>Until now, my understanding was that <em>Copy</em> is just a marker trait for the compiler to allow use after move. Therefore, it influences what code is accepted as correct, but should not influence code generation. In particular, I thought it&#39;s always a good idea to derive <em>Copy</em> when possible.</p> <p>So imagine my surprise when I experimented with the following type:</p> <pre><code>#[derive(Clone)] enum IntOrBool { Int(i64), Bool(bool), } </code></pre> <p>On my machine (AMD Ryzen 5 3600), cloning a value of this type takes ~2.5ns. However, when I additionally derive <em>Copy,</em> that time goes up to ~4ns. That&#39;s 60% slower!</p> <p>Does anyone know what&#39;s going on here? The only explanation I can possibly think of is that the compiler does some ostensible optimizations only allowed due to <em>Copy</em> semantics, which unfortunately end up being pessimizations after all? (Indeed, when I disable optimizations, the effect goes away.) But that sounds rather odd and hand-wavy, so I would really love to understand that in detail.</p> <p>PS Some anticipatory clarifications:</p> <ul> <li><em>If the type implements Copy, why call .clone() instead of just copying?</em> I think both should be compiled to exactly the same thing, so it shouldn&#39;t matter. But just to make sure, I also measured it, and yep, I get the same slowed down performance when copying directly.</li> <li><em>Maybe these differences in measurement are a weird side effect of the artificial microbenchmark setup?</em> Certainly possible. Also, I&#39;m definitely not a pro with these types of benchmarks, so maybe I did something stupid and these values are not really measuring what I think they do. However, the reason I started looking into this and found this minimal example is that I came across this effect in a real-world setting: An language interpreter I wrote slowed down by about 10% <strong>end-to-end</strong> when I added <em>Copy</em> to a type where I initially forgot it. So there is definitely a real effect here.</li> </ul> <p>EDIT: Here is my benchmarking code (uses <code>criterion</code>):</p> <pre><code>use criterion::{criterion_group, criterion_main, Criterion}; use std::hint::black_box; fn criterion_benchmark(c: &amp;mut Criterion) { let copyable = Copyable::Bool(false); let not_copyable = NotCopyable::Bool(false); let mut group = c.benchmark_group(&quot;copy slowdown&quot;); group.bench_function(&quot;copy&quot;, |b| b.iter(|| black_box(&amp;copyable).clone())); group.bench_function(&quot;no copy&quot;, |b| b.iter(|| black_box(&amp;not_copyable).clone())); } criterion_group!(benches, criterion_benchmark); criterion_main!(benches); #[derive(Clone, Copy)] pub enum Copyable { Int(i64), Bool(bool), } #[derive(Clone)] pub enum NotCopyable { Int(i64), Bool(bool), } </code></pre> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/jogru0\"> /u/jogru0 </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1h8dj64/why_can_deriving_copy_pessimize_performance_by_60/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1h8dj64/why_can_deriving_copy_pessimize_performance_by_60/\">[comments]</a></span>",
      "flags": null,
      "enclosureUrl": "",
      "enclosureMime": ""
    }
  ]
}